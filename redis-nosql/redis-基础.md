# 概览

主要两个功能 ：
1. 内存缓存
2. NoSql-DB

官网：
>redis.io

下载地址：
>https://redis.io/downloads/#redis-stack-downloads



|                                 |                      |        |     |     |
| :------------------------------ | :------------------- | :----- | --- | --- |
| Redis                           | 最基础的，经常使用的           | 开源/社区版 |     |     |
| Redis Stack                     | 针对redis的扩展。          | 开源/社区版 |     |     |
| Redis Cloud                     |                      | 开源/社区版 |     |     |
| Redis Insight                   | 图形工具，管理基础 redis 的GUI | 开源/社区版 |     |     |
| Redis Enterprise Software       |                      | 企业版    |     |     |
| Redis Enterprise for Kubernetes |                      | 企业版    |     |     |
| Redis OSS & Stack               | Redis                |        |     |     |


## 内存缓存

使用最多的，效果最好的，且是接触最早的，因为：DB 抗不了太大的压力，使用缓存能瞬间提升性能，效果立竿见影。
>尤其，早期使用 memcached ，再用 redis 就是当成它的替代品

具体的使用场景：
1. 复杂的DB-SQL-QUERY ，读一次就行了，剩下的直接从缓存拿数据
2. 复杂的DB-SQL-QUERY，需要二次计算、联表查询的，走缓存
## NoSql-DB

1. 一些统计类的数据，像：签到、PV/UV、阶段性访问人数、每天的访问 UID
2. 复杂的数据结构：队列、列表、集合、GEO、bitmap 等
3. 简单的数据，不需要存DB的，KV类型的

# 线程组

6.0 以前：主线程 + 后台线程
>4.0引入，增加些辅助线程，6.0 正式使用

6.0 以后：主线程 +  woker 进程组 + 后台线程

网络模式：SELECT/Epoll/kqueue/

6.0 之后，主线程 换成了多线程：

- 把网络 IO 性能提上来。
- 指令阻塞（删除某个大 KEY 的时候）

为什么是6.0加入多线程？

多线程/多进程是占用 CPU 时间更长，而REDIS的瓶颈是  内存控制 + 网络IO
单线程的优点是：代码少，维护成本低。线程切换开销等于没有


# 线程组


| 线程名             | 解释                                         |     |
| :-------------- | :----------------------------------------- | --- |
| redis-server    | 主线程，所说的redis是单线程主要指redis-server这个线程，用于处理命令 |     |
| bio_close_file  | 异步关闭大文件                                    |     |
| bio_aof_fsync   | 异步AOF刷盘                                    |     |
| bio_lazy_free   | 异步清理大块内存                                   |     |
| io _ thd _ *    | IO多线程                                      |     |
| jemalloc_bg_thd | 后台线程，管理动态内存分配与释放                           |     |

>redis-server 就是主线程
## 主线程

主线程（6.0 以前）：网络 IO 、指令解析、执行指令，返回结果。
主线程（6.0 以后）： 指令解析、执行指令，返回结果

 wokrder 进程组：网络 IO 

> 我猜：redis 的 瓶颈是在内存管理上，而不是 CPU。在网络 IO 与指令 IO 上，单线程应该是够。如果加上多线程，肯定得上锁机制、线程安全等等，太复杂。

## 后台线程

持久化、异步删除、主从复制、过期处理

3类线程：
1. BIO_CLOSE_FILE：关闭文件FD。
	- AOF / RDB 产生的临时文件
	- 副本数据同步过程中的临时文件（比如 RDB 文件）
	- socketFD	
1. BIO_AOF_FSYNC：aof 追加指令、aof 重作日志   
2. BIO_LAZY_FREE：异步删除，主要是删除大 key。（del unlink flushall flushdb）

每个线程都有一个队列，主线程会发送消息给队列，这3类线程来做为消费

>前两个，是直接跟文件写操作有关，最后 个是间接跟内存写有关

## 辅助线程

RDB ，每次快照时，他 创建一个新的线程 bgsave

 

## 主进程


死循环：

- 定时器：在 select timeout 时间超时之前，去执行定时器
- 定时器会取一个 小根堆里 取里面的要执行的函数
- 更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等
- 清理数据库中的过期键值对
- 对不合理的数据库进行大小调整
- 关闭和清理连接失效的客户端
- 尝试进行 AOF 或 RDB 持久化操作
- 如果服务器是主节点的话，对附属节点进行定期同步
- 如果处于集群模式的话，对集群进行定期同步和连接测试



# 性能测试

redis\-benchmark \[option\] \[option value\]





# 公共的一些指令



| 指令 | 解释 |
|:---|:---|
| dbsize |  |
| monitor |  |
| info |  |
| info replication |  |
| role |  |
| keys | 列出所有的 key |
| exists： | 判断 KEY 是否存在 |
| expire key second： | 设置一个 KEY 在多少秒后失效 |
| dump key： | 将 value 序列化，目前不确定有啥实际用处 |
| EXPIREAT key timestamp： | 设置一个 KEY 在 UNIX 时间内失效 |
| PERSIST key ： | 删除 KEY 的失效时间，变成永远 KEY |
| TTL key ： | 返回 KEY 的剩余失效时间 |
| rename key newkey ： | 重命名一个 KEY |
| TYPE key ： | 返回当前 KEY 的数据类型 |
| del key： | 删除 KEY |
| STRLEN key： | 返回一个 KEY 的长度 |
|  |  |
|  |  |
|  |  |  


# 公共的策略

1、如果容器不存在，即创建。
2、如果容里没有值，即删除。

注：如果给一个 key 设置了过期时间，然后你又 set 这个 key ,那么之前的过期时间就消失





# 持久化

## RDB

也叫快照，即：一次备份整个 redis 的所有存储数据

在备份过程中，主线程是不停的，数据不统一，如何处理？
- 读操作基本不用管
- 写操作才是需要做处理的

1. 主动触发，管理员输入指令，阻塞主线程的执行
2. 自动触发，主线程 先判断是否有 bgsave 线程，如果没有 fork 子进程 bgsave ，fork 过程阻塞，之后就交由子进程操作


触发条件：
- M秒内发生了 N次写入/修改操作
- debug reload
- shutdfown
- flush

bgsave 的具体操作：
1. 主线程读操作，bgsave 不影响 
2. 主线程写操作，需要内容 复制出来 ，bgsave 要将此数据拿出，存于临时文件
3. 最后把临时文件的内容 保存成新文件
4. 把旧文件删除
>服务器挂了，这里最多会丢失一次备份

自动触发机制如何设置？

- 设置的过小，就会频繁触发备份机制，吃性能
- 设置的过大，一但崩溃，丢失的数据过多

文件的存储方式：
1. 可以选择是否压缩
2. 二进制数据
3. 数据的内容是：键值对，KV

缺点：硬盘的 IO 太慢，如果访问量过大，同时还有个 bgsave 线程在后台做硬盘IO，性能基本上吃光了

## AOF

Append Only File，即只允许追加不允许改写的文件。将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。

AOF 持久化策略是每秒钟 fsync 一次

>具说，早期是 RDB，发现性能不好，加了AOF这种方式

只做指令记录，不做复杂的 二进制/压缩 临时文件等这些RDB 的处理方式，确定能略简单点

#### 3种机制：
- always,同步写回，可能性高，数据基本不丢失，每个写命令都要落盘，性能差
- eversec ，每秒写回，适中，最坏丢失1秒内的数据
- NO ，操作系统控制 的写加，性能好，丢失数据可能过多

#### 重写

随时时间变长，aof 文件变大，得有个清理的机制。
主线程会 fork 出  bgrewriteao 子线程来完成

触发条件：文件多大、两个文件的差值 / 上一次文件的大小

优点：不做全备份，性能略高于 AOF
缺点：恢复时，速度不如 RDB 文件


## 混合模式

4.0之后，出现的新模式：
1. 快照依然还可以进行，可以把周期设置的大一点
2. 在周期期间产生的数据，以 AOF 的指令写入到 RDB 文件中，即：RDB文件即有二进制数据也有AOF文本数据
3. 在周期间 rdb 会把AOF数据转换成正常的二进制数据 

## 恢复

redis 启动的时候，检查到有 rdb  文件就会自动恢复，如果即配置了 RDB 也配置了AOF，优先AOF

但不管哪种方式吧，都会把  redis 启动变慢 

## 小结

既然是内存缓存，就为了追求速度，我个人更推荐不用 持久化，硬盘IO太慢，恢复也慢，另外：缓存本就没有实际意义，是从DB里可以重新生成的，丢就丢了吧。

但这里有个例外，就是完全把 redis 当 KV 数据库使用，这种情况，我还是建议能有自己的恢复策略，完全依赖 redis 有点过分。



# 事务

- multi：开启事务
- exec ：执行事务的指令队列
- discard ：结束事务，并清除队列指令
- watch：监控某个值是否发生了改变
>只能在事务之前使用，它会影响后面的事务，在执行事务期间发现值变了，则自动失败

-unwatch：取消监控
> exec discard 就不需要再 unwatch

执行过程：

1. 开启事务
2. 发送若干指令给 redis server
3. redis 把指令暂存队列中
4. redis 如果接收到： multi exec discard watch 会立刻执行指令队列
5. 如果是 之前有 watch ，判断值是否改变，如果改变了，终止事务
6. 即使指令错误，跳过错误指令 继续向下执行正确的指令（没有回滚 ）
7. 最终返回结果(也包括执行错误的指令)

事务不可以嵌套
multi 之后再发送 multi 会出错，但不会影响一个事务失败
multi 之后再发送 watch 会出错，但不会影响一个事务失败

开启事务后，任何操作都是 返回：queue，告诉 C 端，该指令已接收到，等待最后批量执行
如果期间有脚本是错误的（语法 ），会提示
最后 exec 执行，但如果期间有脚本 出错，后面的指令依然还是会执行。

## watch 原理

有一个链表：watched_keys。存储被监视的 key ，key 对应客户端 ID，一个 KEY 同时可能被多个 client 监控。
在执行:set del lpush 这些指令时，执行结束后。会检查该 key 是否有监听的客户端，如果有：将该 client conn 标识出，此连接有监控的值被修改了。此时如果 client 再发送事务，直接拒绝，也算是间接实现了 回滚吧。

discard，只是是结束了当前事务脚本
所以，redis 事务，只是保证了一组指令执行，并不支持回滚~

## 为什么用事务？

redis 是单线程执行指令，按说不存在抢夺资源的情况，服务端确实不存在 ，但是客户端可能存在。
主要是对某个 KEY 的竞争，先发的指令，因为网络原因造成最后执行。而后发的指令的，先执行了。

## 回滚


redis 官方就不支持所谓的 DB 回滚，解释就是：redis 要性能的，不会额外开销搞 undo redo 
翻译过来：程序员应该控制好并发，出错是程序的问题。。。

也会两种会回滚：
- 指令在编译的时候，出错，比如：指令写错了   ， 如：  setset a  ，就没有 setset 这条指令。
- 触发 watch

大部分不会回滚，如：
假设 a 是列表，你用操作字符串操作，如： set a  1 ，这种编译时是不会错误的，执行时才出错，这种就正常执行，后面指令依然执行。不会回滚

## 使用场景

- 某个 KEY 经常被修改，加个 watch 
- 分布式锁
## 小结

感觉 redis 的事务并不是 DB 的事务，没那么高级，如：
1. 没有回滚机制
2. 没有阻塞/等级机制，传DB 会直接阻塞，等其它连接处理完，接着处理

很鸡肋，感觉它不应该叫事务，应该叫：锁，可以给某个KEY加乐观锁。至于它事务更像是无差别批量执行redis 指令

# 过期策略/生存周期

大策略：
1. 过期删除策略
2. 内存淘汰策略

## 过期删除策略

### 惰性删除



当给key设置失效时间，redis 就会把它保存于  expires dict
```c
typedef struct redisDb {
    dict *dict;    /* 数据库键空间，存放着所有的键值对 */
    dict *expires; /* 键的过期时间 */
    ....
} redisDb;
```

当执行 get 时，会去  expires dict 中，查看下此key是否在失效链表中，如果在，判断是否失效 ，如果失效 则删除

### 定期删除

10次/秒  对 redisDb 扫描一次。

1. 从过期字典中随机取20个KEY
2. 如果有过期的就删除
3. 如果超过5个，即：25%，则重复步骤1
4. 如果时间大于25ms  则停止循环

## 内存淘汰策略

### 当内存满了后，如何处理

1. 不进行淘汰，直接报错
2. 进行淘汰
	1. 在设置了过期时间的数据中进行淘汰：
		- volatile-random：随机淘汰设置了过期时间的任意键值；
		- volatile-ttl：优先淘汰更早过期的键值。
		- volatile-lru（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
		- volatile-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；
	2. 在所有数据范围内进行淘汰
		- allkeys-random：随机淘汰任意键值;
		- allkeys-lru：淘汰整个键值中最久未使用的键值；
		- allkeys-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。
			
### lru

Least Recently Used 最近最少使用

随机找5个值，然后淘汰最久没有被使用过的
### lfu

最近最不常用

记录每个数据的访问次数

## 小结

过期删除策略没什么好的说，内存淘汰策略我是觉得，没必要 ，当 redis 内存占有率大于80%左右的时候就应该预警了，然后再加上：淘汰掉那些有失效时间的即可，上LRU LFU 意义不大，感觉redis 在写LRU LFU 算法 的时候也是比较简单，它的初衷依然是：把问题显性的交给程序员自行解决，不要依赖 redis


# 分布式锁

分布式锁，我另外一遍文章写过，可参考。这里，直接上 redis 如何实现：

1. SETNX + EXPIRE(value=过期时间+随时值)
>非原子操作
2. set local_resource_id value NE EX 10（SET的扩展命令）
3. 使用Lua脚本(包含SETNX + EXPIRE两条指令)
	- 长时间占用锁，会阻塞其它连接
	- 长时间占用锁，超出key的失效时间，再执行删除操作，很可能是其它连接的锁
1. 开源框架:Redisson，接上面，当获取锁后，进行检查： expireTime / 3 = 每次时间
>好像是基于 java 的
3. 多机实现的分布式锁Redlock
>redis作者给的方案，主要是解决主从模式/多点出现故障，有点像是etcd cosule 的模式了，选举/应答制度。太复杂了。不推荐  




# 删除操作

先看看是否过期

同步删除(del)：阻塞。

异步删除(unlink)：它会计算成本
	1. 如果较小且不复杂，还是走同步删除，
	2. 否则，打个删除标记(给变量置成 null)立刻返回，不阻塞。之后 ，lazyfree(BIO_LAZY_FREE) 线程 介入 
>大于64的走异步 ，简单类型的直接删除 ，复杂的 像  集合，走异步删除更好些。