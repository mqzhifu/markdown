# 系统调用

进程如何访问 其它应用程序，如open、pfintf等，系统提供了一组接口。

系统调用是一个抽象层，那上在用户空间与硬件设备之间。LINUX中，系统调用是用户空间访问内核的唯一手段，除异常外。其实C库已经编写了N多函数，供使用

用户空间的程序无法执行内核代码，也就是不能调用内核空间中的函数，可以通过软中断（异常）切换到内核态去执行

响应中断：一个中断产生后，会找到中断flag,再找相应的执行函数，其实这个函数可以理解成驱动

处理器是禁止中断了，也就是SA\_INTERRUPT标志，中断程序就必须重置这个标志，

中断相关信息：vim interrupt

原子操作

atomic\_t v ;定义了一个原子变量V

atomic\_t u = ATOMIC\_INIT\(0\); 定义且赋值0

atomic\_set \(_v_,4\);_a__t__o__m__i__c__a_​_d__d_\(2,_a_v\)

printk\("%d\\n",atomic\_read\($v\)\);

原子整数操作最觉就是计数器，使用复杂的琐机器保护一个单纯的计数有点笨拙。

自旋琐：多处理器，N个执行线程，当有一个线程获得了自旋琐其它，线性必须等待，或者说其它线程在循环等待，这个是最级别的琐

还有读/写自旋琐

VFS:虚拟文件系统，不同的硬盘介质，如：ext ,fat,NTFS,如何进行访问，通过 VFS抽象层

VFS分为4个部分：超级对象块、索引节点对象、目录项对象、文件对象

超级对象块：super\_block结构体，也有一个链表进行保存，只要是硬盘的一些基信息，如：设备标识符等

有个重点元素:sb\-\>s\_op,这里保存的都是该对象的所有 方法

索引结点：包含了文件最后修改时间等信息，在访问才，才被内核在内存中创建

硬盘：物理最小单位是扇区，但是系统逻辑最小单位是块，块包含一个或多个扇区，大小不能超过一个页的大小

当一个块被调入内存时，它要存储在一个缓冲区中，每个缓冲区与一个块对应，保存在buffer\_head结构

bio,聚散IO，用一个链表，存储不同位置上的块，这是新的方法，取代了buffer\_head

IO调试程序，管理IO请求队列，俩种方法减少磁盘寻址时间（电梯算法）：合并与排序。

合并：将俩个或多个请求结合成一个新请求。将相邻区的请求合并

排序：磁头是顺时针或者逆时针读取数据，将请求队列中，按照 时针的顺序排序，这样能减少 碰头来回调转，此方法称为电梯调试

IO写操作：应用程序发出请求，但是实际的写是异步处理，但是读操作不行，是相反的，会发生阻塞。虽然写操作不浪费时间，但是应用程序必须等待读请求完成后才能运行其它程序。（写\-阻塞\-读）

IO调试策略，共有4种方法：最终期限、预测、完全公正、空操作

最终期限：

读请求FIFO队列

写请求FIFO队列

排序队列

排序队列和上面的一样，也是合并排序，但是有个问题是，当某一个队列占住了线程，下面的请求就无法继续了，所以，最终期限设置了一个过期值：读是500毫秒，写是5秒。当一个请求过来之后，先向排序队列里插入一个元素，同时向读/写队列里插入一条。当请求队列里有超时的元素，就会调取另外俩个队列中的元素。因为FIFO中的元素都是按照时间插入，所以保证了优先

预测：

系统定时器：记录了一段程序的设备，该设备记录脉冲，以一个平均的速度，对CPU产生中断

实时时钟（RTC）：存放系统时间的设备，即使断电后，也由主板电池供电，它与CMOS集成一体

CMOS

BIOS

墙上时间：实际的时间
