# 概览

计算机是用电驱动的，电：正负极，数据与模拟信号，最终只有：0 和 1，所以，计算机最根本的操作，如：执行一条指令，基本都是位操作

## 什么是位\(bit\)？

计算机最底层的肯定就是 0 和 1，也叫机器数，二进制码，而由 0 和 1 表示出人类能看懂的东西，大概就是叫做位运算吧

## 进制

1. 2 进制：加减乘除中，缝 2 进一，这个就是要讲的重点
2. 8 进制：加减乘除中，缝 8 进一，用的不多
3. 10 进制：加减乘除中，缝 10 进一，人类最习惯的进制方法，不过在计算机底层的领域使用不多
4. 16 进制：加减乘除中，缝 16 进一，使用较多，主要是节省代码显示

# 单位

| 单位   | 换算                           |
| ----- | ------------------------------ |
| bytes | 字节，8 个二进制位组成一个字节 |
| kb    | 1024 \* 1(bytes)               |
| mb    | 1024 \* 1(kb)                  |
| gb    | 1024 \* 1(mb)                  |
| tb    | 1024 \* 1(gb)                  |

# 字节


其实就是把计算机最小处理单位再加一层，原本可能要计算 80 次，而用字节实际计算 8 次就够了。有点像是公式，就是套上几个系数或代数，方便计算。

为啥字节是 8 位？不是 10 位？6 位？
我的理解是：6 8 10 都可以，重要的是取一个平衡值，性能最大化。估计曾经那帮牛逼的人们最最终计算出 8 可能是最优的，然后，各大厂商跟进，约定死了就是：8 个 bit，最终就一直延续下来了...

既然有了字节为毛还学位运算？
位运算的性能是最高的，且还可以学一些算法，当然可能更大成分是为了装逼...

以下所有 DEMO 均以字节为单位，就不再复述了，也可以是字 或者双字单位，都无所谓

# 正数/负数

一个字节的第一位为 1：即是负数
一个字节的第一位为 9：即为正数

有符号数：同上
无符号数：一个字节的第一位就是有用的数据，不做符号位

分析：同样一个字节，有符号数有效位数就是 7 位，而无符号数是 8 位，所以，无符号数可表示的正数多一倍，但没有负数 ，有符号数虽然正数少了一位，但可以表示负数.

# 溢出

有符号数说：\-256\+1 = 1

# 原/反/补-码

1. 原码：拿出一个字节的第一位当符号位
2. 反码：正数不变，负数第一位不变，其余位取反
3. 补码：正数不变，负数第一位不变，其余位取反，最后加 1

举例，当前有值为\-1：
原码：10000001
反码：11111110
补码：11111111

> 明显，正数无所谓，负数的情况下，一个数会有 3 个不同的编码结果，那么问题就出在负数上~

因为首位是负数，计算起来跟正数就是不太一样，加减乘除都得考虑这一位符号位，人脑计算能记住这种情况，但是计算机如果每次计算还得去分析首位就有点浪费时间了。

根据去处法则 1 \- 1= 1\+（\-1）= 0 ，这样就不需要减法了. 于是就在负数上开始动脑筋了.

> 1 \- 1 = 1 \+ \(\-1\) = \[0000 0001\]原 \+ \[1000 0001\]原= \[0000 0001\]反 \+ \[1111 1110\]反 = \[1111 1111\]反 = \[1000 0000\]原 = \-0

先将两个数都转换成反码，然后相加，最后再进行一次反码操作.

这种操作都是对的，但是有个特殊：0，即：\-0，这就有问题了，于是又出现补码了

> 1\-1 = 1 \+ \(\-1\) = \[0000 0001\]原 \+ \[1000 0001\]原 = \[0000 0001\]补 \+ \[1111 1111\]补 = \[0000 0000\]补=\[0000 0000\]原

先将两个数都转换成补码，然后相加即可

结论：运算时，对负数做特殊处理，间接等于符号位也直接加到了计算过程中。

# 位运算

## 与运算

> 两个字节里的相同位置上的：二进制位做运算，如果都为 1 即为 1，其余都为 0

## 或运算

> 两个字节里的相同位置上的：二进制位做运算，只要其中一个出现 1 即为 1，只有同时为 0 时才是 0

## 异或运算

> 两个字节里的相同位置上的：二进制位做运算，相同即为 0，不同则为 1
> 实际应用：判断两个数是否相等

## 左移/乘法

> 一个数字向左移动一位，即是剩 x2，左移 2 位即 x4

## 右移/除法

> 一个数字向左移动一位，即是除 2，右移 2 位即除 4

取一个字节（无符号数）中的某一个位，比如：从 1 中取最后一位，即第 8 位

00000001，先把此数向左移到 7 位，10000000，再跟 512 做与操作，即：10000000 & 10000000 = 10000000，再向右移 7 位，00000001

从数字 9 中取第 5 位

00001001 向左移动 4 位 10010000,再跟 512 做与操作，即：10010000 & 10000000 = 10000000，再向右移 7 位，00000001

# 实际应用场景

## 大写转小写：

a | 空格\(32\) = 97\(01100000\) | 00100000 = a

A | 空格\(32\) = 65\(01000001\) | 00100000 = a

原理其实也挺简单：大小写 之间的 a\-A 差是 32，32 是 2 的整数倍，间接等于二进制的某一位，\<或\>运算，就是计算这一位数，如果已经为 1 了，即不操作，如果是 0 的，改成 1，实际上是，间接给大写字母的 ascii 码值加了 32

## 小写转大写：

a & 下划线\(32\) = 97\(01100001\) | 01011111 = a

A & 下划线\(32\) = 65\(01000001\) | 01011111 = a

原理是：小写的字节 ascii 码减 32，关键位：第 3 位，也就是 00100000=32，这个是反向的操作，只有这一位 0，其余均是 1

大写转小写，小写转大写，用异或

a ^ 空格\(32\) = 97\(01100000\) ^ 00100000 = 01

A ^ 空格\(32\) = 65\(01000001\) ^ 00100000 = a

判断两个数字是否相等：异或运算

不使用判断 if ，判断 ，如何判断两个数的大小

假设丙从此 a=10 b=12

a\-b = \-2
