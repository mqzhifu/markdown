# 概览


一个程序，编译的时候，被划分成若干个区，其中，主要牵扯到内存的是：堆和栈
栈：简单的变量都存在这里，可能还有一些函数的入口之类的也在，大多由编译器控制
>因为有数据结构，速度较快，但空间较小

堆：像一个对象、数据、map 等都在这里。比较大的内存申请都在堆上，且给程序员使用
>空间比较大

程序员日常使用中，会经常在堆上申请开辟内存空间，供 CPU 使用。当不使用的时候，要释放掉

内存泄露：堆上无用的内存
>像创建的对象不使用了，没有手动释放

垃圾回收：就是把内存泄露的内存，回收起来，以便后续的程序能继续申请到内存
>重点：如何精准且快速的找到这些内存块

回收方法的测量：
1. 不能产生内存碎片
2. 不要 STW
3. 回收要精准，不能误删
4. 速度要尽可能的快
# root 对象

1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。


root 对象，就是垃圾回收机制的起始点
对于一个对象是否被回收，可以计算其是否'可达'


# STW : stop the world

当触发了 GC 时，即触发 STW。用户态的所有执行代码，暂时停止。也好理解：内存有IO并发问题，GC在内存DELETE而用户代码又在执行，那就乱了。

STW就是各类语言在做 GC 最难的地方，停顿时间的长短就是优化的方向 。


# 垃圾回收方法


#### 引用计数法


![[GC-引用计数.png]]
每个对象在创建的时候，加一个成员变量，存储是否被其它引用
当计数变量归0后，即时删除

优点：简单，可以即时删除
缺点：
1. 循环引用，A引用B，B也引用了A
2. 多一个成员变量，吃内存

>php python oc 

#### 标记清除法 

![[GC-标记法.png]]

1. STW
2. 标记（可达）出哪些可用/不可用
3. 统一清理

优点：简单
缺点：内存碎片

>具说 golang 1.3 就使用此方法

#### 复制法

![[GC-标记复制法.png]]
1. STW
2. 从内存中单独划出半区域(不允许用户使用)
3. 标记（可达）出哪些内存不是垃圾
4. 把无用的删除，用的内存统一复制到空白的内存块中

优点：不会出现内存碎片
缺点：
1. 浪费内存空间
2. 内存对象的移动吃性能


#### 标记整理

![[GC-标记整理法.png]]
1. 标记（可达）出哪些内存不是垃圾
2. 将可用的内存移动到内存的空白另一端
3. 最后清除掉边界(可用内存)的所有内存

标记法都有一个共同的问题：需要 stop the world 

#### 分代式

1. 对象在创建时，加一个成员变量，记录创建时间
2. 找出一个 值（因子）
3. 用创建时间与此值进行比较
4. 小于此值：年轻代。大于此值：老年代
5. 还有个永久代
6. 回收时：年轻代更容易被检索，老年代不用过度检索

以 JVM 为例，内存被分成：
1. 年轻区
- eden区
- 幸存区
	- from 区
	- to 区
1. 老年区

![[java-gc.png]]

具体实现：
1. 新添加的对象，都会进入到年轻区
2. 如果年轻区满了，会进行一次 Young GC ，使用的标记复制法：
	1. STW
	2. 标准出所有对象
	3. 把正常的对象，移到TO区
	4. 清空 eden 区
3. 添加对象后，eden 区又满了，再一次 Young GC
	- STW
	- 标出所有对象
	- 把正常的对象，移到 TO 区
	- 如果此时TO区也满了
		1. 判断To区有哪些可以晋升到老年区（具说是每个对象YGC一次年龄加1，到15就可以移到老年区了）
		2. 把TO区的对象复制到from区
		3. 清空To区
		4. to 区 与  from 区 对换（逻辑对象，只是分区的名发生了改变）
	- 清空 eden 区
	


触发Full GC执行：
1、调用 System.gc() 时，系统建议执行Full GC，但不是必然执行的
2、老年代空间不足
3、方法区空间不足
4、通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5、由Eden区、S0区向S1区复制时，对象大小大于S1区可用内存，则把该对象转存到老年代，切老年代可用内存小于该对象大小。

优点：
1. 内存被分类后，性能更好
2. 内存复用率也还可以

缺点：
1. 年轻区的 GC 过于频率
2. 复制标记法，内存移来移去吃性能
3. STW

#### 三色法


白色：未搜索的对象，在回收周期开始时所有对象都是白色，在回收周期结束时所有的白色都是垃圾对象
灰色：正在搜索的对象，但是对象身上还有一个或多个引用没有扫描
黑色：已搜索完的对象，所有的引用已经被扫描完

![[GC-三色法.png]]


具体过程：
1. 初始时所有对象都是白色对象
2. 从 GC Root 对象出发，扫描所有可达对象并标记为灰色，放入待处理队列
3. 从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列
4. 重复上一步骤，直到灰色对象队列为空
5. 此时所有剩下的白色对象就是垃圾对象


优点：
- 不需要暂停整个程序进行垃圾回收

缺点：
- 如果程序垃圾对象的产生速度大于垃圾对象的回收速度时，可能导致无法及时收集
- 线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量


# GO 的 GC 方法


三色标记法（1.5版本引入）

三色标记有个问题：如果不使用 STW，也就是：GC 程序与用户程序一起跑

假如：
A指向B，此时，用户断开了A与B的联系，那么B（应该被回收）
此时，又有一个D指向了B。碰巧在这期间正好GC启动回收了B
>可能觉得这种并发过于极端

#### 屏障机制

强三色（插入屏障）
不允许黑色直接指向白色
>上面的D就是黑色直接指向了白色B

如果当前黑色节点指向了一个白色节点，将白色节点变成灰色，这样 GC 还会重新扫描该 灰色节点，最终该灰色变成了黑色

弱三色（删除屏障）
所有被黑色对象引用的白色对象都处于灰色保护状态。
弱三色不变式强调，黑色对象可以引用白色对象，但是白色对象上游必须有灰色对象来保证其安全被扫描到



内存被分为堆和栈

插入屏障，堆上使用。栈上不使用，需要二次扫描，并开启STW


缺点：
- 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；
- 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。

GO V1.8引入了混合模式
# GO 具体实现

第一阶段：

1. stop the world
2. 每个 processor 启动一个 mark worker goroutine 用于标记（用于第二阶段工作）
3. 启动 gc write barrier（记录一下后续在进行marking时被修改的指针）
4. 找到所有 roots（stack, heap, global vars）并加入标记队列
5. start the world，进入第二阶段

第二阶段：

1. 从标记队列里面取出对象，标记为黑色（不能GC）
2. 然后检查是否有是指向另一个对象，是，则加入标记队列
3. golang中分配对象会根据是否是指针分别放到不同的span中，根据这个如果span是指针span，那么就需要继续scan下一个对象，否则停止该路scan，取队列中下一个对象继续scan
4. 在扫描过程中，如果用户代码修改对象，那么会触发写屏障，将对象标记为灰色，并加入单独的扫描队列中

第三阶段

1. stop the world
2. 处理 marking 过程中修改的指针
3. makeing

第四阶段

1. 到这一阶段，所有内存要么是黑色的要么是白色的，清楚所有白色的即可
2. golang的内存管理结构中有一个bitmap区域，其中可以标记是否“黑色”
3. sweep

所以，GO为了减少 stop the world 的时间，在第二和第四阶段即会重新开始执行用户态的代码。第一和第三阶段会停止用户代码执行。

GC触发条件

1. 内存大小阈值， 内存达到上次 gc 后的2倍
2. 达到定时时间 ，2m interval

这里有个小问题：触发条件有点高，第一条的阈值会动态的一直递增，而第2条的时间周期又有点长。