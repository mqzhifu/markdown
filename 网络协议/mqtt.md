# 概览

Message Queuing Telemetry Transport

因其小巧、简单，性能高，被物联网广泛使用


协议具体内容可参考：
https://www.cnblogs.com/dongkuo/p/11360419.html
# 协议号

| 协议号 | KEY | 说明 |  |
| ---- | ---- | ---- | ---- |
| 0 | Reserved | 保留 |  |
| 1 | CONNECT | 请求连接 |  |
| 2 | CONNACK | 请求应答 |  |
| 3 | PUBLISH | 发布消息 |  |
| 4 | PUBACK | \(qos=1\)发布应答 |  |
| 5 | PUBREC | \(qos=2\)发布已接收，保证传递1 |  |
| 6 | PUBREL | \(qos=2\)发布释放，保证传递2 |  |
| 7 | PUBCOMP | \(qos=2\)发布完成，保证传递3 |  |
| 8 | SUBSCRIBE | 订阅请求 |  |
| 9 | SUBACK | 订阅应答 |  |
| 10 | UNSUBSCRIBE | 取消订阅 |  |
| 11 | UNSUBACK | 取消订阅应答 |  |
| 12 | PINGREQ | ping请求 |  |
| 13 | PINGRESP | ping响应 |  |
| 14 | DISCONNECT | 断开连接 |  |
| 15 | Reserved | 保留 |  |

以上是，MQTT的所有协议号，代码级别可控制的是1\-14，0和15是保留

# 协议分析

一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成

```
+----------------------------+
|      固 定 头 部 (必 需 )    |
+----------------------------+
|     可 变 头 部 (非 必 需)   |
+----------------------------+
|        载 荷 (非 必 需 )     |
+----------------------------+
```

> 固定头（Fixed header），存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。
> 可变头（Variable header），存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。
> 消息体（Payload），存在于部分MQTT数据包中，表示客户端收到的具体内容。

## 固定头

长度2\-5字节\(变长\)

Byte 1

报文类型\+标识
> bits 0:retain
> bits 1\-2:qos level
> bits 3:dup flag
> bits 4\-7：报文类型，messageType，也就是消息类型，0\-15

Byte 2

数据长度（变长头\+消息体）,remaining length
> 最多4个字节，每个字节7位是正常数，保留一位标识是否连接后面字节。

ps:单字节最大可表示的数：2^7，4个字节是2^28，最多可表示的长度为256Mb左右。也就是说消息大小，最大值肯定不会超过256M

```

+---------------------------------------------------------+
|   bit   |  7  |  6  | 5   |  4  |  3  |  2  |  1  |  0  |
+---------------------------------------------------------+
|  byte1  |      Packet type      |         Flags         |
+---------------------------------------------------------+
| byte2...|              Remaining Length                 |
+---------------------------------------------------------+

```

结合看，前2个字节必须得有，固定头至少得2个字节，至多是5个字节

## 变长头

这个比较复杂，不同的协议号，变长头都不太一样,这里就不做一一复述了，挑几个重点吧。

有些协议号是需要有packet id 、payload ，有些是不需要的。

payload

消息体，这个就不做复述了，下表：

|Control Packet|Payload |
|--------------|--------|
|CONNECT       |Required|
|CONNACK       |None    |
|PUBLISH       |Optional|
|PUBACK        |None    |
|PUBREC        |None    |
|PUBREL        |None    |
|PUBCOMP       |None    |
|SUBSCRIBE     |Required|
|SUBACK        |Required|
|UNSUBSCRIBE   |Required|
|UNSUBACK      |None    |
|PINGREQ       |None    |
|PINGRESP      |None    |
|DISCONNECT    |None    |

packet id

2字节，最大10进制数 ：65536

|Control Packet|Packet Identifier field|
|--------------|-----------------------|
|CONNECT       |NO                     |
|CONNACK       |NO                     |
|PUBLISH       |YES \(If QoS \> 0\)    |
|PUBACK        |YES                    |
|PUBREC        |YES                    |
|PUBREL        |YES                    |
|PUBCOMP       |YES                    |
|SUBSCRIBE     |YES                    |
|SUBACK        |YES                    |
|UNSUBSCRIBE   |YES                    |
|UNSUBACK      |YES                    |
|PINGREQ       |NO                     |
|PINGRESP      |NO                     |
|DISCONNECT    |NO                     |

这个ID，个人感觉意义不太大，因为：每个clientId，每次启动的时候，会都会被初始化为1，那就是A跟B的pid 是完全可能出现重复的情况


# 主题

```
/game/register
/game/order/add
/education/class/beging
......
```

像路径一样，以反斜杠分隔

# 持久化


如果发送的消息，无人订阅，暂存到内存中，最后，落盘

>注：MQTT 主打的是 小 和 快 ，跟队列系统不一样，也没必要持久化
>是否持久化，是可选项，或者具体实现协议的程序员来决定，但也最简单的缓存一些消息
>甚至激进的话，直接丢弃消息


# 消息可靠性

QoS 0：消息最多传送一次。不管 S/C 端是否正确 接收/消息 ，只发一次
QoS 1：消息至少传送一次。
- 发送者在发送数据包之前，需要将消息暂存起来；
- 在发送消息后，需要等待接收者的确认。
- 若长时间（自己定义）没有收到接收者的确认，需要重发该消息，直到收到接收者的确认响应为止
QoS 2：消息只传送一次。
- 客户端发送消息，并保存消息，等待S端确认，如固定时间内未收到，重发
- S端收到消息，暂存，并发送确认消息，等待C端确认，如固定时间内未收到，重发
- C端收到消息，确认S端已收到，删除暂存消息，并发送确认消息
- S端收到消息，删除暂存消息

最快：QoS 0
最慢：QoS 2
最稳：QoS 2
最平衡：QoS 1

QoS 2：IO性能肯定非常差，最多适用于对安全性较高的场景。
QoS 0：有丢消息风险，但对一些不重要的场景可以使用，或者默认就这种模式，直到出现丢消息再换
QoS 1：这个消息比较平衡、折中，可以考虑日常都用这个


# 发消息

指定一个主题即可

消息可靠性可参照上面的策略做选择

# 订阅/消费消息

可订阅一个或多个主题。订阅多个时要使用通配符

+：表示单层通配符，例如 a/+ 匹配 a/x 或 a/y。
\#：表示多层通配符，例如 a/# 匹配 a/x、a/b/c/d。


消息可靠性可参照上面的策略做选择

# MQTT 与 传统队列系统 区别 


没有负载均衡
>原生不带什么负载均衡、镜像，自己可以在MQTT 上层做

没有分区/备份
>一个主题就是普通的一个队列/管道

没有持久化 
>只存于内存中，可以做简单的持久化

简单化主题/分类
>就是以路径的形势存在，只有这一种

简单化的消费
>就是以路径的形势，不支持其它形式的消费

# 总结 

不要把传统的队列系统与MQTT弄混了。
mqtt 的优点是：小 快
适于一些性能很低的IOT设备，只是用来传输一些较小的数据，讲究：实时性



