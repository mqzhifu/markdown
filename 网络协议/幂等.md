
# 概念


幂等：一个接口/一次请求，不论执行多少次，结果都是一样的。
请求的协议类型：
1. HTTP协议
3. GRPC协议
4. TCP/UDP
>不仅仅是前端请求后端，也可能是后端请求后端


一个接口出现不幂等的情况(请求了两次及多次)：
1. 用户多次点击一个按钮
2. 网络波动，请求可能是多次
3. 重试机制
4. 浏览器中：用户刷新页面、用户点击后退按钮


解决办法：前端+后端


# 前端解决


1. 按钮点击一次就置灰
2. 短时间内按钮只能点击一次
3. 监听：后退、刷新事件，防止重复请求
4. 前端生成一个唯一值，每次请求附加上

# 后端解决
## token-唯一值

前端每次请求接口之前，都向后端申请一个token值，再进行真正的接口请求
缺点：每个接口都要请求2次，效率太低
优点：是最安全的

比较适合一些对安全性较高的业务：支付、密码修改等

## 分布式锁

每次请求过来，先去 REDIS 里设置一个值：
- 成功，继续执行
- 失败，证明：此时正在有其它进程在处理，证明这次请求是重复的。

key 的设计 ：UID+业务名+唯一值

问题：
- 并发，两个请求同时到达后端，redis 必须保证一致性，只有一个请求能拿到锁
- 请求拿到锁了，但是执行的时候挂了，其它请求拿不到锁
>给锁设定一个失效时间

应用场景：某个业务一次执行时间较长，进行排队等待
## 数据库乐观锁

给数据库表增加一个 version 字段，可以通过这个字段来判断是否已经被修改了
先 select 查询到 记录的 version
再 update xxx where version = 上面查出的结果

应用场景：update 修改较多的时候使用

## 状态机控制

状态都有流转，一般是DB中一个int类型的字段，保证此值都是正向加1，也就是：
该字段值只能增加不会减少

update `order` set status = #{status} where id = #{id} and status < #{status}