# 概览



#### OSI  对比 TCP/IP

![[TCP对比OSI.png]]

> OSI参考模型的过于庞大、复杂招致了许多批评。

数据的传输的过程：都是逐层向下增加报文头

![[网络传输-数据逐层封装.png]]

> 图上，用户发送一次数据的大概过程。经过每层，都需要在原数据前面加上本层的信息。

![[网络传输-进程间通信.png]]


TCP/IP：实际是上一组协议，大体上分为：TCP协议\+IP协议组成

TCP协议负责的是本机数据的处理：数据拆分包、传输的稳定性、端口映射进程等，而网络的路由，对端机器的寻找，这些交给IP层来做，最后加上物理层传输二进制数据，基本上就满足了网络请求


![[网络各层-协议.png]]
# TCP 协议格式

transmission control protocol ，传输控制协议

TCP\-数据格式：

![[TCP协议.png]]

1. 源端口号\(16位\)

> 从上面看到端口号：2^16=65535个

1. 目录端口号\(16位\)
2. 初始序号ISN\-顺序号\(32位\)
3. 确认序号\(32位\)
4. 头部长度/数据偏移\(4位\)
5. 保留
6. 标志位，6位
    1. URG：紧急指针
    2. ACK\(Acknowledgement\):确认序号有效
    3. PSH：接收方应该尽快将这个报文段交给应用层
    4. RST：重新连接SYN：同步序号用来发起一个连接
    5. SYN表示SYN报文（在建立TCP连接的时候使用）
    6. FIN：发端完成任务
7. 滑动窗口大小\(16位\)
8. 校验和\(16位\)
9. 紧急指针\(16位\)
10. 可选项\(8的整数倍\)
11. 数据

## 分析

相比IP协议，TCP可要复杂不少

1. 连接机制：建立连接，断开连接

> 确认号、顺序号、连接标志

1. 滑动窗口机制\(保证可靠传输，并且有顺序性\)

> 另外我们看到，TCP里没有IP地址信息，TCP并不是关心网络层的事情，更关心:数据的传输，端口映射进程的相关事情

# TCP 创建连接(握手)

![[TCP三次握手.png]]

#### 基础术语

顺序号\(sn\):32位\-正整数\(0~4294967294\)

确认号\(ack\):接收方，把发送方发来的顺序号\+1

x：任意一个自然整数，由客户端系统生成，也是sn号

y：任意一个自然整数，由服务器系统生成，也是sn号

客户端状态：

1. SYN\_SENT：请求连接状态
2. ESTABLISHED：连接成功
3. CLOSED：连接关闭

服务端状态：

1. LISTENING：监听状态
2. SYN\-RCVD状态:收到和发送一个连接请求后等待对方对连接请求的确认
3. ESTABLISHED状态:连接成功

#### 三次握手

第一次握手：客户端发送包\(头\), flags 字段中的 SYN=1 ，随机生成一个数:x，sn=x,到服务器，并进入SYN\_SEND状态，等待服务器确认

第二次握手：服务器收到包\(头\),，判断 SYN=1，是要建立连接，于是，返回包\(头\)：随机生成一个数y, SYN=1,ACK=1,sn=y,ack=X\+1，此时服务器进入SYN\_RECV状态

第三次握手：收到服务器的包\(头\)：判断 SYN=1，ACK=1，这是确认连接，然后，向服务器发送确认包头：ACK=1，sn=x\+1、ack=y\+1\)，客户端进入 ESTABLISHED 状态

服务端接收到客户端的确认信息后，进入 ESTABLISHED 状态 完成三次握手。

> 看着是3次握手，实际两端要处理逻辑其实共计是4次，3次更多的是指网络请求走了3次而已

整个过程：只需要处理头信息即可，包里并没有任何数据。两端各生成一个随机数，以确保是安全的连接

发送数据

当连接那上成功后就要发送数据了，正常一个数据段，可能很长，也可能很短。拿比较长的来说，数据先会被写到缓冲区，然后打包成TCP报文段，直到最后一段数据进来，再次进行打包，然后加此报文的flags中的psh置成1，ack设置成1，统一发送出去。

接收方，会把报文，依次放入到 读，缓冲区。如果全部收全且发现有psh标识,则立刻通知应用层进程，来拿数据。再返回给发送方一个ACK~之后。

这里，如果保证发送方的数据，接收方都能够接全。就牵扯到 窗口滑动机制了。

#### 握手-解决的问题

1. 连接的过程中，可以双方协定一些参数，如：CWND、窗口扩大选项、时间戳选项等服务质量参数
2. 确定双方是否都处于在线状态

# TCP关闭连接

> 结合上面的图

#### 4次握手：

1. A发了关闭请求 \(FIN=1、seq=x、ack=z\)，状态变成：fin\_wait\_1状态
2. B接收到，判断标识位FIN=1\(seq=z、ack=x\+1\)关闭了其中一个通路，然后给A发起一个ACK
3. A接收ACK确认此条线路被关闭，状态切换到 fin\_wait\_2状态.B再发出关闭请求FIN，进入last\_ack状态
4. A收到关闭ADK请求，然后再给A发送一个ACK，进入time\_wait 状态

> A经过2个MSL后，自动关闭此条连接

最后，B接收到，判断标识位FIN=1\(seq=x、ack=y\)再关闭一条通道，到此全关闭了

MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃。

#### TIME WAIT

tcp连接是全双工(双通道)模式，某一端：断开了一条通道后，如果再断开最后一条通道后，在这期间可能出现：某条消息对端发出来了，但网络抖动迟迟没有收到，结果通道直接关闭了，就丢消失了。

timewait 状态就是保证尽可能不丢消息，要等待2msl的时间。
然而，就是这种明明连接全断，但还要等待一会的策略，当：连接数过大时，socket 的连接数被用光了。



# TCP连接的漏洞

## 半连接

当服务端接收到C端的连接请求后，会发包，然后进入 SYN\-RCVD 状态，而如果迟迟等不到C端的第三次握手请求，就会产生一堆的半连接

未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN 包，并向客户发出确认，正在等待客户的确认包。

这些条目所标识的连接在服务器处于 Syn\_RECV 状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。



# keepalive

keepalive:保活机制。

拿 linux socket来说，虽然各种书籍文档都说网络要建立连接，而这个'连接'并不是真实有个链接，道理很简单：真要是有根物理的网张创建连接，那一个服务器得有多少条这样的网线？不现实。

实际就是：双方做个验证，留个TOKEN之类的，再由 OS 接管，弄2个socket FD，而已。

那么，这条虚拟的连接，如果双方不消息，双方又如何知道对方是否还在线呢？

FIN这种关闭是有很多问题的，如：

1. 对方进程挂了，OS直接无视，根本没来得及发FIN，
2. 某一方网络出了问题，也发不出去FIN
3. 某方CPU计算量非常大，而当前进程拿不到CPU资源，只能等待。
4. 丢包
    ....

> 发不出去FIN的情况其实很多的......

#### 心跳机制

headerbeat：心跳机制，对于上面说的两端如何知道对方在线？其实也没有太好的办法，异常太多，于是 就有了一种折中的方案：两端定时发送一个空包，一但超过一定时间 未接收到，就证明对方可能网络出现了问题，就可以主动关闭了

TCP\-keepalive

> cat /proc/sys/net/ipv4/

3个重要参数：:

tcp\_keepalive\_time：默认 7200 秒

tcp\_keepalive\_probes：默认 9 次

tcp\_keepalive\_intvl：默认 75 秒

> 7200秒后，对方没有响应，就发送一个探测包，之后每75秒后再发送一个包，发送9次没响应，关闭连接


#### 应用层-自己实现-heartbeat

虽然TCP已有了KEEPALIVE，但问题是，以TCP层，只是能确定，连接是否存在 ，并不能确认该连接是否还能传输数据

比如：对方主机假死，连接在，不能接收数据了


# 术语



#### mtu : maxinum transmission unit

以太网帧头部占14个字节，和帧尾占4个字节，共计18个字节，最后 报文就是1518\-18=1500


#### MSS

Maximum Segment Size：最大报文段，是TCP协议的一个选项。

在TCP建立连接时，双方协商一个TCP报文段所能承载的最大数据长度。
MSS选项只在初始化连接请求(SYN=1)的报文段中使用。

选择合适的值很重要：
- 如果MSS小了，网络利用率低。
- 如果MSS大了，由于在网络层需要分片，影响网络传输性能。
 
一般MSS的长度为：MTU(1500)-IP首部(20)-TCP首部(20)=1500-40=1460字节

通常TCP头还多一个12字节的 unixstamp，1460 - 12 = 1448

#### 5元组

源IP+源端口+协议类型(TCP/UDP)+目标IP+目标端口

>将此5个值合一起，组成一个新的ID标识

#### MSL maximum segment lifetime

close time wait 最大报文生命周期，默认是2分钟

#### 数据分片

作用于IP层的，这层是将IP数据发给数据链路层封装成：数据帧，但前提是不能大于1500个字节，一但大于就得将数据分片了，分片除了发送的时候，首部的计算麻烦，接收方，也得要计算
比如：A B C 数据帧都到了接收方，接收方得 排序 A B C 然后，组成成一个完整的数据发给TCP层

### 数据分段

TCP层，MSS分段，既然IP层也会做分片，为什么TCP还得再搞出来个分段呢？因为IP层是非可靠传输，被分成若干片的数据，如果其中一片数据丢失，TCP并不知道是哪片数据丢了

故~会导致整片数据重新发送，加大了网络开销，如果在TCP层，提前避免分片，就可以提高效率，即：TCP分段产生。



# RTT 

Round-Trip Time，往返时间

测量：很复杂的东西，正常来说，每次通信的 RTT ，可能都不太一样。
另外这里还牵扯到重传，是以第一次成功为准 ，还是以重传的周期为准 。

#### RTT\_S 计算公式

带权算法：

RTT\_S1 = RTT1

RTT\_S = \(1\-a\) X 旧的RTT\_S \+ a x 新的RTT\_S

a = 0.125

#### RTT\_D 公式

RTT\_D1 = RTT1 / 2

新的RTT\_D = \(1 \- B\) X 旧的RTT\_D \+ B X | RTT\_S \- 新的RTT样本 |

B = 0.25


# 数据重传

网络传输数据时，肯定会遇到一些异常情况，如：丢包、网络抖动


#### RTO/重传时间

Retransmission TimeOut

TCP 为了实现可靠传输，实现了重传机制。最基本的重传机制，就是超时重传
>实际就是一个定时器，一个定时器内，未收到响应，执行一个<重传发包>操作

这个定时器时间设置就比较烦，最简单的方式，至少要略大于RTT。
>麻烦的是：先要计算出RTT

公式 ： RTO = RTT\_S \+ 4 X RTT\_D

#### Fast Retransmit 

它不以时间为驱动，而是以数据驱动重传。

- 第一份 Seq 1 先送到了，于是就 Ack 回 2
- 第二份 Seq 2 由于网络等其他原因，没送到
- 第三份 Seq 3 到达了，但是由于 Seq 2 没到，于是还是 Ack 回 2
- 后面 Seq 4 和 Seq 5 都到了，由于 Seq 2 没到，于是还是 Ack 回 2
- 发送端收到了三个 Ack = 2 的确认，知道了 Seq 2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2
- 最后，收到了 Seq 2，此时因为 Seq 3，Seq 4，Seq 5 都收到了，于是 Ack 回 6

但快速重传还可能会有个问题：ACK只向发送端告知最大的有序报文段，到底是哪个报文丢失了呢？并不确定！那到底该重传多少个包呢？

比如上面在进行重传时，是只重传Seq 2呢，还是 3，4，5 都需要重传？

#### select Retransmission

选择重传

- 发送方，可一次发送N条数据帧
- 接收方也同样可可接收N帧
- 接收方，会在一个RTO 内等待 窗口内的所有数据帧到齐后返回整体ACK，即使序号不一样，也无所谓，只要在窗口期整体的所有数据帧都能正确收到即可
- 如果发现某些帧有错误码的，会立刻返回 NACK，这样发送方接收后，就单独重发这条数据帧，而不用整体重发

对比上面两种方，选择重传真的做到了，发送方可以N条，接收方N条，并且重发机制也能做到具体到某帧重发，整体效率比较好

#### GBN \- go back N

后退 N 帧协议

发送方，可一次发送N条数据帧，但是接收方只能有一帧确认机制，如：

1. A 发送了 帧012345 B接收到012345 ，OK，B返回ACK=5
2. A 发送了 帧012345 B接收的则是015234 ，B返回的ACK=1，即：01是正常的，因为是有序的，5234是错误序号的，那，即A就得重新发送5234

与SW方法比起来，不同点是：发送方可以一次多发几条数据，感觉并没有快太多

#### Duplicate SACK

略


# TCP窗口滑动


TCP 发送一个数据，需要收到确认应答，才会发送下一个数据。这样有个缺点，就是效率会比较低，于是引入了滑动窗口机制：
- 发送窗口
- 接收窗口


#### 发送窗口

当进程，将要发送的数据，发送到缓冲区后~该区域就把所有数据打上4种标识

1. 已发送且已收到ACK确认
2. 已发送但未收到ACK确认
3. 未发送的数据（接下来，即将要发送的数据）
4. 未发送的数据（暂时不发，等第3步发送完成的）


1和4没什么说的
2和3需要做特殊处理，会被一个 虚拟的 窗口覆盖上
当2步数据经过确认后，窗口自动向右滑动

![[TCP滑窗口机制-发送方.png]]

SND.WND：发送窗口的大小
SND.UNA：W未确认的，它指向的是已发送但未确认的第一个字节的序列号
SND.NXT：表示下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号

#### 接收窗口

RWND receive window

接受方每次收到数据包，在发送确认报文的时候，同时告诉发送方，自己的缓存区还有多少空余空间，缓冲区的空剩余空间，我们就称之为接收窗口大小

即：如 rwnd = 100 ，发送者下次最多就能发送100个字节

rwnd= 0，这个是接收者告诉发送者，不能再发送消息了，此时发送者不能再发送任何消息了，发送者注册一个RTO。

数据被打上3个状态标识：
- 已接收并确认
- 未接收，但可以接收
- 未接收，且不可接收

![[TCP滑窗口机制-接收方.png]]

当被确认后，窗口会向右移

#### 小结

两端，通过各种维护一个窗口机器，就实现了数据的：
1. 包的传输顺序
2. 丢包的处理/重发
3. 最大并发/性能提升


# TCP flow\-control

让发送方的发送速率不要太快，这样接收方有足够的时间接收

方法：由接收方控制发送数据的速率

1. 停止\-等待 stop\-wait
2. 滑动窗口

停止等待：每发一帧，都得等待接收方发一条ACK消息，效率太低

滑动窗口:双方维护一个窗口大小，同一时间，只能传输窗口大小的数据

# 拥塞控制

整个算法机制 ，由下面4种算法配置完成：

1. 慢开始 slow\-start
2. 拥塞避免 congestion\-avoidance
3. 快重传 fast retransmit
4. 快恢复 fase recovery

CWND： congestion window ，发送方维护一个拥塞窗口
SWND：send window
ssthresh：慢启动阀值(slow start threshold）


#### 流程

- 初始化 cwnd = 1
>表明可以传一个MSS单位大小的数据
- 每当收到一个ACK，cwnd就加一
- 每当过了一个RTT，cwnd就增加一倍; 呈指数让升
- 如何定义发生拥塞 
	1. cwnd > ssthresh 
	2. 没有按时收到 ACK 或 发生了RTO
- 发生拥塞，进入了拥塞避免算法
	1. 每收到一个ACK时，cwnd = cwnd + 1/cwnd
	2. 当每过一个RTT时，cwnd = cwnd + 1
	>显然拥塞避免时的 cwnd 变成了线性增长	
- 如何快速处理拥塞：快速重传
- 如何判定拥塞已结束：快速恢复

#### 分析

刚开始，都是慢开始算法，递增比较快，当到达SSTHRESH阀值后，启动拥塞避免算法，递增步长变为1，也就是发送的帧数变的慢很多。虽然慢，但依然还是在递增，当发送方已到达最大阀后（假设当前发送了20个帧，结果只接收了18个ACK，迟迟收不到那两个，且触发了RTO，即认识可能到达了最大阀值），将当前SSTHRESH缩小一半，同时CWND=1，重启慢开始算法。

开始-》指数增长-》线性增长-》指数降低-》线性降低-》归0-》

总结下：每个连接，开始的时候，都是正常较快流控，但触发了某个阀值后，开始限流，用较慢的方式让该连接传输数据，但当该连接依然有大量的数据发送，且到了最大阀值后，直接清0，重新开始，同时把慢阀值降低~

这里可能有个问题：拥塞避免算法，到达最大阀值的计算方式，即：一但触发了RTO即认为成立，很可能是误判。所以新的TCP版本加入了 快重传 快恢复 算法。

简单说就是：多发几个帧，接收方也快速响应，并做预判。一但这种丢失。这样就会触发多条 重发/NACK 等情况，不可能都处理，以3做为一个阀值。如：发送方收到3条重复确认，但并不开启慢开始算法，而执行快速恢复算法，最后：SSTHRESH\+3

#### TCP Tahoe 版本

慢开始\+拥塞避免 时期的算法，解决拥塞

#### TCP reno 版本

慢开始 拥塞避免 快重传 快恢复



# 粘包

TCP 层，会把数据进行分段，也就是：
1. 发送一段数据，可能会拆分成若干个包
2. 接收方，可能收一次消息是不全的，要收N次才能完整接收一次数据

解决：
1. 发送方，在数据头部加入数据的总长度
2. 在数据中插入特殊字符，如：\N
>接收方如果读到这个数据就证明之前的数据读全了，后面是先的一条数据了