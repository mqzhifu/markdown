# 概览

正常 HTTP 浏览器请求是80端口，HTTPS默认是443端口
原本是想与HTTP合并成一个文档，但发现HTTPS的东西有点多，索性分拆出来吧

https: Hypertext Transfer Protocol Secure，就是对HTTP的升级，网景公司设计\(1999年，SSL被IETF标准化改名为TLS\)。多了一项加密功能：SSL

# SSL

Secure Sockets Layer：安全套接层。介于应用层和TCP层之间

## 数据加密的两种方式：

1. 对称密钥加密\(Symmetric Key Cryptography\)：加密与解密使用相同密钥。
2. 非对称密钥加密\(Asymmetric Key Cryptography\)：加密与解密使用不同密钥

> 这里对加密原理不做过多研究

对称加密

1. 双方持有对方的密钥
2. 用自己的私钥给数据加密
3. 用对方的密钥解密
 
这样做的缺点是：私钥被完全泄露了

非对称加密：

1. 公钥和私钥成对出现
3. 公开的密钥叫公钥，只有自己知道的叫私钥
4. 用公钥加密的数据只有对应的私钥可以解密
5. 用私钥加密的数据只有对应的公钥可以解密
6. 如果可以用公钥解密，则必然是对应的私钥加的密
7. 如果可以用私钥解密，则必然是对应的公钥加的密

具体使用流程：

1. 生成一个公钥，再拿公钥生成私钥，
>用程序生成一对密钥，其实就是生成了两个文本文件
3. 把我的公钥交给对方，对方再将给我一个公钥
4. 我拿私钥加密后，对方可以拿我给的公钥解密，
5. 对方拿他的私钥加密，我可以拿对方给我的公钥进行解密

> 也就是用公钥加密，用私钥解密，这也就是非对称加密

相对于对称加密，这样做的好处是：大家各自只需要把公钥给出去，而私钥是安全的。

问题：算法有了，但是公钥该如何获取呢？

1. 人为的找对方要，然后录入到浏览器中
2. 浏览器自动寻找

方法1不好，看方法2：

1. 浏览器直接找对方要，正常一个请求中间要经过N次路由/代理，某一步做了拦截，把代理的证书发给两端，自己就可以监控两端的数据了
2. 浏览器直接找对方要，但对方只给一个MD5签名串
3. 浏览器再请求3方中介：要对方的公钥及MD5签名串
4. 验证对方的MD5签名串是否正确
5. 用刚刚拿到的公钥加密一个小小的数据给到对方
6. 接收对方返回的数据，用公钥解一下
7. 公钥验证成功

# CA证书

Certificate Authorities

> 上面说的3方中介就是这个CA证书，你到3方中介网站，花钱，填写资料，生成一个CA证书即可。

它包含：

1. 持有者信息：公司名、域名等
2. 证书认证机构
3. 公钥
4. 有效期
5. 数字签名\(签名HASH算法\)

有了CA证书\(数字签名\)，基本上就能确保请求传输过程的安全性了

![[https.png]]
# TSL流程

1. client hello
    1. TSL版本号
    2. 我支持的加密算法
    3. 我支持的压缩算法
    4. 随机数
2. \(2\-1\)server hello
    1. TSL版本号
    2. 挑选一个双方均支持的加密算法
    3. 挑选一个双方均支持的压缩算法
    4. 随机数

> 这个时候已经有两个随机数了

1. \(2\-2\)server Certificate：发送自己的CA证书
2. \(2\-3\)Server Key Exchange：算是对第3步的补充，如果第3步给的数据不够可能C端无法解密
3. \(2\-4\)Server Certificate Request：好像是一些证书的数据，要求C端也要发证书，做双向认证

> 3和4步骤主要是S端要验证C端，貌似没啥用

1. \(2\-5\)Server Hello Done：内容为空，证明S端已发送了本次所有的数据，等待C端响应
2. \(3\-1\) Client:先请求3方验证证书的签名是否正确，如果正确，取出公钥，再生成一个新随机数\(pre\-master key，用服务端公钥加密\)

> 此时一共已经有3个随机数了

1. \(3\-2\)Client Certificate：发送客户端证书，让S端认证
2. \(3\-3\)Client Key Exchange
3. \(3\-4\)Certificate Verify：把之前所有交流过的数据用客户端私钥加密，通过签名方式，验证客户端身份

> 2、3、4步骤好像是由S端决定，如果S端只是单向验证，这3步都可以省略了

1. \(3\-5\)ChangeCipherSpec:
    1. 告知对方验证OK
    2. 生成主密码：把3次的随机数进行加密\(用双方协定好的 加密算法\)
2. \(3\-6\)finished:告知对方本次通话结束
3. \(4\-1\)finished:告知对方本次通话结束

其实核心是4步：

client hello \-\> server hello \-\> ChangeCipherSpec \-\> finish


### 数据传输的算法

从TSL中看到：4次握手过程，只是为了生成一个会话密钥，且该密钥是对称的，S端也能解出来
>会话密钥=公钥加密（对称加密算法（第1随机数+第2随机数+第3随机数））

握手时是非对称加密，而握手通过后，创建一个session\+临时私钥，数据均是对称加密

## 不使用CA，自己生成证书

CA证书虽然好，但是要花钱，且是定期续费不是一次性购买并且有点贵

所以，自己生成 公/私 钥 文件 server.key/server.pub。

server.pub打包\<域名/申请者/公钥\>，生成 文件.csr，发给CA服务器。

ca验证没问题后，用ca.key加密生成server.crt，返回给服务端

csr：Certificate Signing Request，将制作好的证书打包，发给CA

crt：certificate，即证书，csr打包信息，提交申请，通过后CA给的

cer：同CRT一样，适用于WIN

key：

pem：Privacy Enhanced Mail，BASE64编码

DER：Distinguished Encoding Rules,打开看是二进制格式,不可读

//cer转crt

openssl x509 \-inform PEM \-in certificate.cer \-out certificate.crt

通信原理：

C \-\> S

S \-\> 服务器证书

C \-\>用S端证书 访问CA认证，如果没问题，生成随机 公私钥、会话密钥

C\-\> 拿S端公钥加密：C端公钥、会话密钥，发给S

S \-\>用服务器私钥解密，拿到：C端公钥，C端会话密钥

S \-\>生成随机 会话密钥，用C端公钥加密，发C端

C \-\> 用私钥解密，拿出 S端 会话密钥

C \-\>用 会话密钥加密数据 ，发送S端

制作流程：

1、OPEN\-SSL，生成一个 私钥KEY

openssl genrsa \-out rsa\_private.key 2048

根据KEY，生成csr，发送给CA机构认证

通过后，会返回cer或crt文件

# openssl

这只是一个指令工具集，包括 各种加密算法、密钥加密解密、密钥生成、证书生成等

一共有8种对称加密算法，7种组算法：AES、DES、Blowfish、CAST、IDEA、RC2、RC5，一种流加密算法是RC4

4种非对称加密算法 ：DH、RSA、DSA算法和椭圆曲线算法（EC）

还有5种信息摘要算法，分别是MD2、MD5、MDC2、SHA（SHA1）和RIPEMD。

PKI是Public Key Infrastructure，公钥基础设施，可以理解成一组框架协议机制。并实现了私钥的PKCS\#12和PKCS\#8的编解码功能

摘要加密：一般是用MD5，比如你要传一个文件，那么把文件内容整体做MD5，生成一个32们的摘要，一并发给对方，如果这期间你修改了文件内容，那么摘要就对不上。
