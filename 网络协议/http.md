# 概要

Hyper Text Transfer Protocol：超文本传输协议

> 只是一个网络传输协议

# 一次HTTP操作

先看流程图吧：
![[HTTP请求.png]]

1. 用户在本机开启浏览器应用程序，然后输入域名
2. 浏览器会先请求 DSN 服务器，拿到IP
> 浏览器内存 DNS 缓存,/etc/host配置,主机dns缓存
3. 浏览器用IP\+PORT，与服务器端建立 TCP 连接，双方正常建立连接 
> 3次握手
4. 浏览器根据用户输入的URI，请求S端，获取HTML代码
5. 浏览器解析HTML代码
    1. HTML里还依赖一些资源，二次请求继续获取资源
    2. 将JS代码将给V8引擎执行
    3. 将最终的HTML套上CSS样式，送给浏览器器
6. 浏览器把最终渲染好的结果，显示在浏览器窗口内
7. 浏览器断开TCP连接

分析

1. 依然是建立TCP上
2. 一次请求正常过后，就会断开连接
3. 浏览器帮忙做了DNS解析 建立长连接 JS代码执行 图像渲染

# 协议详情

协议的格式大体分成两个部分：

1. 请求
2. 响应

> 基本上格式差不多，只是具体的KV值不太一样而以

## 协议详情\-请求

请求内容的格式分为四个部分：

1. 请求行\r\\n
2. 头域\\r\\n
3. 空行
4. 消息体（可选）

> 其核心就是：header\+body

## 请求行

> GET /index.php?a=1 HTTP/1.1
> 
> 方法 [空格 ] 请求URI\[空格\]版本号\\r\\n

方法类型:

1. GET
2. POST
3. HEAD
4. PUT
5. DELETE
6. OPTIONS
7. TRACE
8. CONNECT

> 其实就：GET POST用的最多，然后 head 跨域会用一些，其它的基本很少很少使用
> 像：delete/put 直接p被：get/post 的URI中包含关键字给代替掉了，如：http://www.baidu.com/user/delete/id/1

### 请求uri:Uniform Resource Identifier

用来标识你想请求服务端的资源

### 版本号：

1. 1.0/1.1
2. 2.0

> 用来告知影响方：请求方当前的HTTP协议版本号，具体2.0如何处理后面再讲

## 请求头

先看看一个demo:

```
Host:www.baidu.com \r\n
User-Agent:Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN; rv:1.9.2.13) Gecko/20101203 Firefox/3.6.13
Cache-Controlmax-age=0          使用何种缓存机制
Data:Mon,30 Nov 2009 13:15:39发送请求的时间
Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8   浏览器可接受的MIME类型；
Accept-Charset:GB2312,utf-8;    浏览器可接受的字符集
Accept-Encoding：gzip,deflate  浏览器能够进行解码的数据编码方式
Accept-Language：zh-cn,zh  浏览器所希望的语言种类
Authorization：授权信息
Connection：keep-alive 表示是否需要持久连接
Keep-Alive:115
Content-Length：表示请求消息正文的长度；
Cookie：这是最重要的请求头信息之一；
```

就是个KV值......主要就是告诉接收端：请求方的一些配置信息而以..... ，接收方，接到这些配置信息，根据请求方要求自行来定制化处理

请求头的 key 格式要求：首字母大写，单词间用中划线分隔


几个常用的头key做个讲解吧：

| key              | desc               | purpose                                         |
| ---------------- | ------------------ | ----------------------------------------------- |
| Host             | 标识请求的域名            | 后端可根据域名做代理与分发                                   |
| User\-Agent      | 标识请求方的来源信息         | 如：OS版本 设备类型 浏览器版本 等，这个经常用，尤其写爬虫的时候必须得用。反爬虫也会用到。 |
| Accept           | 告知接收方，请求方可以接收的数据类型 |                                                 |
| Accept\-Charset  | 可接收\(优先\)的字符集字符集   | 如：gbk gb2312 utf8，有时候乱码就是由此字段引起                 |
| Accept\-Encoding | 传输内容的编码格式          | gzip 字符流，可用于压缩传输内容，加快传输性能                       |
| Cache\-Control   | 请求缓存               | 像js css这些纯静态文件，基本不会改变，也没必要每次请求都向S端拿             |
| Connection       | 是否短时间内开启长连接        | 可避免每次连接重复创建TCP消耗性能                              |
| Cookie           | 客户端存储的数据           | HTTP是短连接，不存数据，没有状态，利用cookie就有状态数据了              |
| Upgrade          | 将连接升级成 websocket   | 长连接                                             |
| Authorization    | 当前请求方的用户名密码        | 有些网站不需要自行实现登陆，仅通过浏览器做些简单的验证                     |
| Referer          | 上一个页面的来源           | 可做些反爬虫验证、页面跳转                                   |
| Via              | 代理                 | nginx代理再发往后端，后端想知道nginx的一些信息                    |
| Range            | 请求一部分              | 大文件，分多次请求下载                                     |
|                  |                    |                                                 |

从这些头中分析，HTTP可做的事情还是很多的：

1. 性能提升：缓存、部分请求、ws长连接、短时间内长连接
2. 记录状态：cookie

正常编程就是基于这个协议里面有什么，才能做什么

实际上这里面还有很多key，用处不一，只列些实际经常用的，另外：http协议它比较自由，只用一个空格分隔，至于你的 KV 也不一定全是写死，你也可以自定义一些，如：

```
X-Token:abcdabcdabcdabcdabcdabcdabcdabcdabcdabcd
X-Source:baidu
X-Access:IMtest
```

> 它的官方建议是：自定义的HEADE\-key，最好以大写X开头
## 消息体

> abc=22&abcd=33 ，没什么可说的....

依然是个 kv 值形态

## 协议详情-响应

1. HTTP状态行\\r\\n
2. 响应头\\r\\n
3. 3空行\\r\\n
4. 4可选的消息体

> 跟请求的格式一样一样的......

## 响应\-行

> HTTP/1.1 200 OK
> 版本号\[空格\]状态码\[空格\]原因说明\\r\\n

HTTP/1.0 每次请求都需要建立新的TCP连接，连接不能复用。HTTP/1.1 新的请求可以在上次请求建立的TCP连接之上发送，连接可以复用。优点是减少重复进行TCP三次握手的开销，提高效率。

注意：在同一个TCP连接中，新的请求需要等上次请求收到响应后，才能发送。

## 常用响应状态码：

| code | en desc               | cn desc                     | purpose                                          |
| ---- | --------------------- | --------------------------- | ------------------------------------------------ |
| 200  | OK                    | 客户端请求成功                     | 程序员最喜欢的状态码                                       |
| 301  | Moved Permanently     | 永久移动                        | 爬虫的时候遇到过，还有就是：某些网站可能变了域名也可以使用                    |
| 302  | Found                 | 临时移动                        | 同上，不过如果双方的类库支持自动跳转到新页面还好，如果不支持就很烦                |
| 304  | Not Modified          | 未修改                         | 请求方可根据此值使用本地缓存文件，节约网络性能开销                        |
| 400  | Bad Request           | 客户端请求有语法错误                  | C端有公共库，基本上用不到，但如果自己实现HTTP协议会遇到类似问题               |
| 401  | Unauthorized          | 请求未经授权                      | 与Authenticate头配合使用，实现简单登陆验证                      |
| 403  | Forbidden             | 服务器收到请求，但是拒绝提供服务            | apache遇到的最多，大我是请求的资源没有权限                         |
| 404  | Not Found             | 请求资源不存在                     | eg：输入了错误的URL                                     |
| 500  | Internal Server Error | 服务器发生不可预期的错误                | 像PHP JAVA 脚本执行出现错误，或者运行时判断参数不正确等等                |
| 502  | Bad Gateway           | 网关错                         | 大型公司所有的应用程序前面是要有网关，但中小公司基本上没遇到过，倒是前些年淘宝双11的时候遇到过 |
| 503  | Server Unavailable    | 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 | 未遇到过                                             |

简单分析下：

| code | desc         |                                     |
| ---- | ------------ | ----------------------------------- |
| 1开头  | 是C与S连接时的一些状态 | 因为开源的类库双方都有，且稳定，大多都记不住此状态值了......   |
| 2开头  | 基本上都是成功      | 忽略，大家都喜欢此状态                         |
| 3开头  | 请求的资源被移动/改变  | 很少遇到，即使有，C端 类库也会自动跳转                |
| 4开头  | 大多是请求方的错误    | 比较少遇到，因为C端的类库都比较稳定，真遇到了，后端就可以直接喷前端了 |
| 5开头  | 大多是服务端错      | 请求方遇到类似的，直接开喷后端程序员吧                 |

## 响应\-头

```
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html
Server: Apache/2.2.17 (Win32) PHP/5.2.9-2
Last-Modified: Sat, 22 Jan 2011 03:29:17 GMT
Content-Range: bytes 0-5
```

> 跟请求格式基本一样，就是 KV

看一下常用的：

| key                            | desc       | purpose                           |
| ------------------------------ | ---------- | --------------------------------- |
| Content\-Encoding              | 传输的格式      | gzip 压缩                           |
| Transfer\-Encoding             | 报文格式\-分块编码 | 算是对ws协议的优化吧                       |
| Last\-Modified                 | 该资源最后修改时间  | 配合请求端来使用缓存机制，节约网络性能               |
| Connection                     | 长连接        | 请求方如果使用Upgrade做ws长连接              |
| Content\-Range                 | 分片传输时      | 请求方想分段下载大文件时使用                    |
| Content\-Type                  | 当前返回的内容类型  | 当前S端返回的具体的内容，如：html json image js |
| Content\-Length                | 当前返回的内容总长度 | 只是方便接收端处理，很少用                     |
| Location                       | 重新获取资源位置   | 如果有301 302 这种，可以用此参数跳转，很少用        |
| Access\-Control\-Allow\-Origin | 允许跨域访问的域名  | 跨域                                |

常用 content\-type：


| key                                  | desc                                          | purpose                      |
| :----------------------------------- | :-------------------------------------------- | :--------------------------- |
| text/html                            | \|HTML格式                                      | 最常用的，也就是给浏览器解析/执行/渲染         |
| text/xml                             | XML格式                                         | 主要是一些配置文件使用，相比html更严谨，但也更复杂些 |
| image/gif                            | gif图片格式                                       |                              |
| image/jpeg                           | \|jpg图片格式                                     |                              |
| image/png                            | png图片格式                                       |                              |
| application/javascript               | js代码                                          |                              |
| application/json                     | JSON数据格式，这个最常用，前端从后端拿源数据就是这个                  |                              |
| application/pdf                      | 不太常用                                          |                              |
| application/msword                   | 不太常用                                          |                              |
| application/octet\-stream            | 二进制流数据（如常见的文件下载）                              |                              |
| application/x\-www\-form\-urlencoded | \|form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） |                              |
| multipart/form\-data                 | 表单中进行文件上传时，就需要使用该格式                           |                              |
|                                      |                                               |                              |

> 咋形容呢，其实 content-type 只是一个标识，或者说有很大一部分是给浏览器使用的，比如：解析PDF EXCEL MP4 MP3 格式，浏览器可以直接使用\(浏览器插件\)，而我们日常使用最多的是json，像text/html这种 WEBSERVCIE就帮你搞好了。

总之：从类型中也能看出，浏览器能处理的数据类型还是挺多的，再配合是自带的插件，像：播放视频、音频，显示WORD EXCEL文档等等，那浏览器火爆也是必然的啊

## 响应\-体

这个就是不同的 content-type 给出不同的内容了，也可以自行输出内容体，无所谓了，没啥重点可讲。

# http版本对比

1. http1.0
2. http1.1
3. http2.0
4. Chunked transfer\-coding

# http 1.0

这个对比的最基础版，不讲解了

# http 1.1

新的功能点：

1. head of line blocking 链接复用
3. 更多的缓存控制
4. 响应错误码增加
5. 传输性能优化

#### 链接复用

一次HTTP请求，并不立刻断开连接，如果后续还有JS/CSS请求，复用这一个请求
>header 中增加：connection: keep\-alive | connection: close 
>默认开启长连接keep-alive

具体到详细的协议中：
虽然C端可以一次发送N个请求，不阻塞，但是响应方，得按请求方的请求时间，依次响应，严格看，还是会有阻塞问题。但请求方可以并行的发请求。 
>head of line blocking 头部阻塞
>感觉很鸡肋，没提升多少，依然还会阻塞，并不是真正的并行

例子：C端发送一个CSS文件请求，同时又发送了一个JS文件请求。S端先接收到了CSS请求，立刻又接收到了JS请求，这个时候，按照顺序，要先把CSS数据传完，然后，再传JS文件数据

#### 缓存控制

好像也没啥讲的，就是比之前的缓存控制多一些头参数

```
If-Modefied-Since
If-Unmodified-Since
If-Match
If-None-Match
ET-tag
```

#### 响应错误码

性能优化：加入了状态码100，可以先试探S端是否正常，如果正常，再发BODY，勉强算是优化点传输性能吧，感觉挺鸡肋。

#### 分段传输/块传输

将一个大的 body 切成若干小块\(Chunked transfer\-coding\)，分批次传输，这个可以用到断点续传上。



#### 小结

基本上就是一个链接复用算是常用些，其它的都挺鸡肋。

# http 2.0

1. 网络传输性能优化
2. 多路复用
3. 请求优先集
4. header 压缩
5. server push

原本传输的内容是字符流，现改成了二进制流，数据被压缩了，传输性能肯定是有提高的

二进制分帧：在TCP 和 HTTP 层，中间加一层：二进制分帧 。每帧再加上一个stream_id
>header 帧 +  body 帧 

这样每个数据帧都被打上ID，C端拆包的时候，基本不用关心顺序了，能直接划分。
这样，就真正意义上实现了单连接任意发送请求/响应

>个人感觉说了一堆，其实就是TCP加上了一个 channel  功能

server push：S端在接收到C端一个主请求后，会自动把后续的资源请求的东西，也一并推送给C端，这样C端不用再单独发请求，直接从缓存中拿就行了。
>S端不发遵守请求一次响应一次的规则。自己可以做出一些判断，主要是有分帧功能，这个也间接能实现了。

缺点：单连接会因TCP线头阻塞（head\-of\-line blocking）的特性而传输速度受限。加上存在可能丢包的情况，其负面影响已超过压缩头部和优先级控制带来的好处。




# 常用实体

|显示结果|描述    |名称          |编号|
|--------|--------|--------------|----|
|\<      |小于号  |\<            |\<  |
|\>      |大于号  |\>            |\>  |
|&       |和号    |&             |&   |
|"       |引号    |"             |"   |
|'       |撇号    |' \(IE不支持\)|'   |
|©       |版权    |©             |©   |
|®      |注册商标|®            |®  |
|™      |商标    |™            |™  |
|¥       |元      |¥             |¥   |
|¥       |空格    |              |    |
