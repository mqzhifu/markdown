# zigzag

Base 128 Varints 编码（压缩算法）

int：有符号整形，占2个字节（16位），如：

数字 1：转换成2进制->  00000000 00000001（补码）
数字-1：转换成2进制->  11111111 11111111（补码）

我们发现：
- 数字 1转换成2进制后，前面有31个0，都是占位符
- 数据-1转换成2进制后，前面有31个1，都是占位符

能不能优化掉？肯定能，分析:

1. 正数前面的0可以直接干掉
2. 负数不行，在计算机中会被自动转换成补码，也就是占位符变成了1
>负数因为第一位肯定是1，不管是什么数字，最前面这个1不能用常规方法丢掉

核心点：解决负数问题！
>解决负数的符号位问题

这里还有个问题：我们日常定义一个数值的类型，如：int32，其只是可能出现最大值为 2147483647，或者说偶尔出现一次，日常我们人类的数据没有这么大，可能都是些较小的数值。


尝试操作：

1. 左移一位：(空位用0补)

```c++
 1 << 1 ==  00000000 00000010
-1 << 1 ==  11111111 11111110
```

2. 右移15位：(空位用0补)
```
1 << 1 == 00000000 00000000
-1<< 1 == 00000000 00000001
```
3. 将上面两步相加

```
  00000000 00000010 + 00000000 00000000 = 00000000 00000010
  11111111 11111110 + 00000000 00000000 00000000 00000001 = 11111111 11111111
```
4. 对第3步求补码（最后一位不要动）
00000000 00000010 补码 = 00000000 00000010
11111111 11111111 补码 = 00000000 00000001

我们发现：负数也可以压缩了，重复上面的步骤并发析：

- 一个数左移 1 位， 等于把首位删除掉，末尾加个0
- 一个数右移15位， 等于获取了该数的首位的值
- 将两个值合并后：等于把一个二进制数的首位转移到了最后一位
- 最后，将此值的前15位取补码，最后一位不变

结果：
- 正数在末尾加了一个0，负数在末尾加了一个1
- 负数原来前面的1都变成了0

这样负数也可以压缩了。


但还有更巧妙的算法，将 或 运算与 取反运算合并成一步，异或：

00000000 00000000 00000000 00000010

00000000 00000000 00000000 00000000

00000000 00000000 00000000 00000010

11111111 11111111 11111111 11111110

11111111 11111111 11111111 11111111

00000000 00000000 00000000 00000001

> 最终：代码公式：\( n \<\< 1 \) xor \( n \>\> 31 \)

---

解压

1. 先判断最后一位，正数最简单，移动一下符号位即可
2. 负数，得先做<非>操作（最后一位符号位不动），然后再将符号移到首位

---

传输

虽然实现了压缩算法，但是如何将0删除，如何传输还得再定义

1. 把数据中前置占位符删除掉
2. 将余下的字符除以7，进行分组

> 如：zigzag编译后 1000110 011001 ，分成两个组：1000110 011001

1. 传输时最小的组单位是字节 ，8个二进制位，而这里以7位分组空出一位，即用来标识：后面是否还有数据

> 如：1000110 011001 这是两组，也是两个字节，每个字节还能再使用空出来的一位，在1000110前面加1，代表：该组数字要跟后面合起来一起使用，011001 后面没了，所以在其首部加上0最终就是：11000110 0011001



# geo-hash

经度：-180 ~ 180
纬度：-90   ~ 90

把上面4个数，落到二维坐标系上：

![[geo_hash.png]]



把坐标系划分成4个区别：
- \[ - 90°, 0°)：  用二进制0代表
- (0°, 90 °]： 用二进制1代表
- \[ -180°, 0°)：用二进制0代表
- (0°, 180°]：用二进制1代表

每个区域还可以继续划分成4个子区域

![[geo_hash_2.png]]

依此类推，在地球范围内，所有的区域被划分成若干子区域，给出经纬度就能计算出大概的位置


给出经度计算出区域上的 0 和 1 
给出纬度计算出区域上的 0 和 1 

合并经纬度：奇数位是纬度，偶数位是经度（从0开始） = 得出一个总串

总串=BASE32一下 = 最终一个字符串

>实际上，这种 方法是将 椭圆的地球，平铺开~成为一个2维坐标系（分块/区）~再将2维转换成1系（一维曲线）


GEOHash的结果，并不是指一个确定的位置，而是指一块矩形区域，给定的经纬度，大概会这个区域范围内，矩形区域越小，精度越高。也就是结果的字符串越长，精度越高，看下表：


| **geohash长度** | **Lat位数** | **Lng位数** | **Lat误差**   | **Lng误差**   | **km误差**   |
| ------------- | --------- | --------- | ----------- | ----------- | ---------- |
| 1             | 2         | 3         | ±23         | ±23         | ±2500      |
| 2             | 5         | 5         | ± 2.8       | ±5.6        | ±630       |
| 3             | 7         | 8         | ± 0.70      | ± 0.7       | ±78        |
| 4             | 10        | 10        | ± 0.087     | ± 0.18      | ±20        |
| 5             | 12        | 13        | ± 0.022     | ± 0.022     | ±2.4       |
| 6             | 15        | 15        | ± 0.0027    | ± 0.0055    | ±0.61      |
| 7             | 17        | 18        | ±0.00068    | ±0.00068    | ±0.076     |
| 8             | 20        | 20        | ±0.000086   | ±0.000172   | ±0.01911   |
| 9             | 22        | 23        | ±0.000021   | ±0.000021   | ±0.00478   |
| 10            | 25        | 25        | ±0.00000268 | ±0.00000536 | ±0.0005971 |
| 11            | 27        | 28        | ±0.00000067 | ±0.00000067 | ±0.0001492 |
| 12            | 30        | 30        | ±0.00000008 | ±0.00000017 | ±0.0000186 |
8位的 geohash 编码的经度能达到19米左右，9 位的 geohash经度能达到米级，一般情况下能满足我们大部分的需求。而12位就是厘米了：0.0000186km= 0.01860000m=1.86CM


优点：
1. 可以计算范围内的物体
>MYSQL 有一种 query 可以查找，但是性能超级差. gongoDb 有现成的做法
2. 两列加索引略麻烦，单列可以直接加索引，加快搜索性能

缺点：会有 临界值 计算不准的情况


# bitmap

排序

假设 数字范围：0~7，当前给出集合{4，7，2，5，3}

先开辟一个字节并置成0：0 0 0 0 0 0 0 0

循环集合，第一个元素是4，也就是位置为4，把字节置成：0 0 0 0 1 0 0 0

依次类推得出：0 0 1 1 1 1 0 1

优点：不需要进行比较和移位 、占用内存少

缺点：所有的数据不能重复

基数查找\-去重查找

计算用户UV，假设用户ID 范围为：10000000~9999999

比如有10亿个用户访问记录，查找基数

一个整数4个字节~10亿X4=40亿个字节/1024/1024/1024=3.725G

全加载内存有点坑

开辟一个字节\-数组（内容缓冲区）大小为：9999999 /8 =1249999.875 约1.19MB

将UID 映射到 这个数组的位置 ，存在 即为1 否则为0



