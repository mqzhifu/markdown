
# 时间轮

![[时间轴.png]]


假如：现在要自己实现 定时器 功能。其最简单的方法，就是把所有 timer 保存到一个容器中，且要排序，然后轮询。
>效果有点低

优化：把时间按照一定规则划分成若干等份，只在固定时间内执行 N 次即可 
如：把时间以小时划分，每一个小时轮询一次，每次就执行这个时间段的 timer 

容器类型：数组 + 链表

数组：保存每个分段的关键值，如：1 2 3 4 5 6 7 8 9 10 11 12
>每个段后面加一个链表

链表：具体保存 timer 的容器。最好是有序结构，或者小根堆也行，查询更快些

问题：颗粒度。肯定是分段越小，更精准。但如果颗粒太小，那跟轮询也没太大区别了。
所以，还是得根据项目要求，自己进行定义。
>个人觉得普通级别的精确到秒够用了。游戏对实时要求高这种就得精确到毫秒了。

优化：分段如果过大，还可以再增加一个子段，也就是把每个分段再划分成若干个小分段，增加精准度


小结：
时间轮算法，优化的是：在一个固定时间，批量执行定时任务，而不需要时时刻刻都轮询


# 雪花算法


![[雪花UID.png]]

唯一性：生成的 ID 全局唯一，在特定范围内冲突极小。
有序性：生成的 ID 全局或按规则有序，便于数据库插入及排序。
可用性：可保证高并发下的可用性，确保任何时候都能正确的生成 ID。
自主性：分布式情况下不依赖中心认证即可自行生成 ID。
安全性：不暴露系统和业务的信息，如：订单数、用户数….


1bit 作为符号位，总是为0
41bits 用来存储毫秒时间戳，计算后可知约可用69年( 毫秒 2^41 - 1   )
5bits 用来存储数据中心ID，最多可以表示32个数据中心
5bits 用来存储工作机器ID，最多可以表示32台工作机器
12bits 用来在同节点时间相同时作为自增ID标识唯一性，同1ms可以表示最多4096个ID，所以理论上1s内可以生成约409W个ID

