# 概述

数据结构：是一种数据的存放方式。
>如：对现实社会的建模，用户数据表

算法：是对数据结构的计算。
>如：查找某个值，对数据进行排序等

为什么这两个东西总是被放在一起说?
>算法，算的就是数据，而影响算法最大的就是数据的结构\(存储方式\)。不同的数据结构算法也不太一样，有点相辅相成的意思。

分析

1. 任何算法都是基于某种数据结构，单独谈算法纯属扯蛋，不同的数组结构同一算法，差距非常大，返过来也一样，不同的算法相同的结构，差距也非常大
2. 在数据量不大的时候，谈算法也是扯蛋，因为最好的算法跟最差的算法，基本时间相近，反而比较好的算法需要更多的时间去开发维护，增加了复杂度。

> 为什么面试揪着数据结构与算法不放？所有大公司都问这个？

这两个东西影响着计算机系统的千千万万，并不局限是后端还是前端、是软件还是硬件、是现实还是虚拟。算法的进步推动了整个计算机体系的发展与进步，所以，它是：基础中的基础....


# 大O表示表示法

在计算一个算法的好坏\(复杂度\)时，可以使用大O表示法。它的核心就是：给一个算法推算出一个大概的公式（时间复杂度+空间复杂度）。

> 各种算法的好坏：时间复杂度、空间复杂度，都有些公式统一换算成一个公式，帮助做比对分析
> 它算是：对一种算法的好坏进行评估

# 对一种算法的衡量

1. 时间复杂度。插入、删除、查询的平衡速度
2. 空间复杂度。使用了多少资源：CPU、内存、硬盘IO次数等

>一种算法的好坏有很多种衡量因素，这里主要从这2个维度讲起

任何算法就是为了提高速度，只要时间复杂度能提上去，大多会牺牲空间复杂度。

如：

1. 有些内存数据可以释放，但是防止此数据还会被访问，那就不释放...这就是缓存原理
2. 一条记录按说存在一个地方\(表\)，但是为了加快速度，该记录可能还会被存在在其它特定位置\(索引\)


# 分类：

> 根据数据的结构

|大分类|存储方式 |结构                        |应用|
|------|---------|----------------------------|----|
|线性  |顺序     |数组                        |    |
|线性  |链式     |链表                        |    |
|线性  |顺序/链式|队列                        |    |
|线性  |顺序/链式|栈                          |    |
|树    |顺序     |堆                          |    |
|散列表|顺序/链式|哈希                        |    |
|树    |链式     |二叉树/平衡树/红黑树        |    |
|树    |链式     |2\-3树/2\-3\-4树/B\-树/B\+树|    |
|      |         |图                          |    |

3种大的结构，每个结构也可能有不同的算法。另外，开发某一功能，也不一定就非得用一种结构。也可以几种结构混合使用。因为每种结构都有缺点和缺点，没有完美的算法。具体还是得看项目需求。

## 线性结构

一组数据集合：所有元素类型相同，如：int float bool struct 等。将这一组数据用一根线串起来，组成一个集合。进行操作：数据的添加/删除是横向/纵向的，所以他像一根笔直的线

根据存储结构不同，又可分为：

1. 顺序存储结构
2. 链式存储结构

## 非线性结构

数据零散的存储，并不是按照线性存储。也无法按照线性查找。如：hash 散列表，他是根据 KEY 来查找某个值

## 从数据内容分类

#### 有序

数据存储是按照一定规则(如：大小)进行存储。
如：添加元素时，遍历整个数组的所有值，找到应该放置的位置，然后，按照大小依次存放

> 插入是O\(N\) 查询是O\(logN\) 删除是O\(N\)

适合场景：排序的操作多，查找的操作多，插入的操作少，删除的操作少

#### 无序

数据存储并没有按照一定规则存储。
如：添加元素时，可能就是直接在上一个元素后面直接添加

> 插入是O\(1\) 查询是O\(N\) 删除是O\(1\)

适合场景：插入的操作多，删除的操作多，查找的操作少，排序的操作少

> ps:从适合场景中也能看出，没有什么完美的算法，都有各自的优缺点。取决于业务形态，又或者这两种算法同时生效。



# 数组\(线性\)

#### 原理

在内存中开辟一段连续的空间，再对该空间进行等份划分,最后供程序员使用

> 如：a = new array\(10\) int32 ,一个int=4bytes，数组大小为10，10 \* 4bytes = 40bytes ，那么OS会再内存中，找一段空白的40bytes空间，并将该内存地址传回给变量a

#### 组中的元素值是否可重复

###### 不允许

插入的时候，得先遍历整个数组的所有元素

###### 允许

1. 在申请数组大小的时候得注意，因为，申请数组大小为100，但可不一定能放100个人，也可能只放50人\(另外50人是重复的\)
2. 删除的时候想好是删除一个还是重复的元素全删除
3. 添加的时候得考虑好，重复的值是统计放成连续的，还是不连续。如果是连续的，那还得考虑后面的元素做移动
4. 查找的时候得想好，是找到一个即返回，还是得找出全部

> 看起来，允许重复很复杂，不允许重复反倒简单，但依然还得有个O\(N\)遍历操作

#### 数组的长度计算

1. 数组开辟的长度
>如：int a[10]  ，这个数组就是可以存储10个元素的长度
2. 数据实际存储的元素长度
>创建一个100元素的数组，而实际只存了20个值，那这个数组的实在存储长度仅仅是20

算法：

1. 单独再开一个变量，每次加减操作，这个数字 累加累减
2. 每次都遍历整个数组，动态计算最终长度

#### 数组的容量计算

1. 数组开辟的长度
>如：int a[10]  ，这个数组就是 10 * 4  = 40 bytes
2. 数据实际存储的元素长度
>如：int a[10]  ，但实际存储了2个值  2 * 4 = 8 bytes

算法同上

从这里也能看出，数组在使用前必须确定大小，那么一定就会存在浪费内存的情况

#### 总结


###### 优点

1. 遍历、查找操作都较快
>一段连续的内存地址等于有了段地址，操作元素时，偏移即可
2. 使用简单，有下标地址，程序里操作也简单
>int a[10] 就申请一个数组，a[0] 就可以直接索引某个元素值

###### 缺点

1. 必须固定大小，申请大了造成浪费，申请小了扩容很麻烦。
2. 插入/删除操作，要对整个内存地址进行移动，这个吃性能很大。


数组的缺陷性挺大的，正常一个功能，不可能没有删除/添加，一但有类似操作，要么遍历整个数组，要么就得调整整个数组的元素位置，很麻烦。还有，大小固定，一但元素过多/过少还得考虑减少/扩容问题。还有它的是否可重复问题处理起来也挺头疼。

严格来说：数组并不适合做单独的算法，可以配合其它算法一起使用\(Hash\)。或者没太复杂的操作，只是单纯的存一些有共性的值。如：一个大功能中的一小段代码，需要临时有个容器存点东西。


###### 适合场景

1. 小范围的数据，不要太大，或者临时存储的一些值
2. 无序或者数据本身有序，不考虑重复值的问题
3. 查找/删除 操作较少
# 链表

#### 原理 

1. 在内存中开辟一个值，存储一些小数据，同时再开N个这样的值，最后将这些小的内存数据连成一起。

2. 每个节点数据：除了存数据外，额外还要保存2个值，它的上一个节点的地址，和它的下一个节点的地址

#### 分类

单向、双向、循环、有序、无序

优点

1. 内存存储结构比较松散，扩展性强，不需要固定申请内存长度
2. 插入/删除较快，比较灵活

缺点

1. 内存不连续，查找某一个值慢
>没法通过段/偏移值快速定位一个元素位置，得一个一个遍历的查
2. 内存松散，容易造成内存碎片
3. 内存利用率低，因为它每个节点还要多存上/下一个元素的地址


表头 插入或者增加 O\(1\)
查找是O（n） 删除 O\(n\) 任意位置添加 O\(n\)

适用的场景，非常多

1. 栈
2. 堆
3. 队列
4. hashMap
5. 各种树
6. 迭代器

链表才是算法中的大头，应用的场景最多。小范围的数据使用，只会增加维护成本。只有当数据量较大，需要优化，真的需要用算法 的时候，链表是非常好的选择
# 树

[跳转](https://app.yinxiang.com/fx/e65e71b4-1ad7-4af3-ba05-6f12cd8a4353)

# 排序算法探索

[跳转](https://app.yinxiang.com/fx/46a7c5fa-06e3-4b48-a6b7-f1d911fe0a17)

HASH跳转
# 栈

先进后出，只有一个出口，只有一个入口，不允许从栈的其它位置有任何操作。也就是说：没有遍历/查找操作，只能添加/删除操作。

插入是O\(1\)，删除O（1）

使用场景

1. 安卓的\<后退\>功能，进入一个页面就把URL压入栈，这样点击后退按钮的时候，是一层一层的向上后退。
2. 解释器：遇到一个 左括号就压入线，遇到一个右括号就比对，因为一个程序中可能嵌套很多个
    括号，这样保证最近的一个 匹配。
3. 算术表达式中对括号的处理，跟上面有点类似
4. 程序执行器，正常我们程序中定义的常量、变量、函数入口地址等都会被压入到栈中
5. 单词做逆排序

存储容器：栈只是一种算法，每个栈里的元素得进行存储，而存储就可以考虑用数组，也可以用链表。

算是一个小众的算法结构，基本上日常做应用开发，用不到这种。而底层开发用的可能略多一点点，但只适用于特定的场景，还是比较小众。或者说 跟其它算法组合成一个更大的算法。

# 队列

先进先出
主要是将并发较高的消息 => 进行串化缓存/暂存，按时间进行顺序存储
>如：顺序的加、顺序的取。有一定的容错、持久化功能。

#### 分类

无序队列、优先级\(有序\)队列、循环队列、双端队列

> 个人觉得分类挺多，实际大同小异，且应用最广的就是最普通的：无序队列，先进先出

插入是O\(1\)，删除O（1）


#### 存储容器

链表、数组都行，具体看业务需求
>我更倾向用链表，因为 添加/删除 更快~

代码实现：核心就是定义两个变量\+一个容器，一个指向队头，一个指向队尾....

#### 应用场景

>这个太多了

1. 秒杀，将大并发进行串化
2. 解耦两个业务
3. 异步处理

队列已经完全可以大到单独成为一个软件\(消息中间件\)，像：

1. kafaka 
2. rabbitmq 
3. rocketmq

#### 优先级(有序)队列

添加的时候，除了数据还会多一个权重\(索引\)值，队列里的每个元素会根据这个值进行排序，最后权重值高一点的，可能会早一点出去。

> 所以，从优先级队列看，用链表当容器可能灵活性更高一点~删一个/加一个元素不用移动所有元素

应用场景

1. 发短信，不同部门的有不同的发顺序
2. 进程抢占式应用

插入是O\(N\)，删除O（1）

#### 小结

队列是个很大的课题，用应用非常广泛：
1. 只要是并发高一些
2. 数量大一些
3. 开发人员多一些

都得用队列，所以，就有很多的开源工业化的3方软件进行使用，日常自己也不会开发，更多的研究更多应该是市面这些稳定的开源软件

# 堆

> 各种语言中，大类型的内存申请，经常提到：堆，像：对象、数组等，但跟这个堆不是一个东西，这里只是一种结构
> 这里指的是：大根堆、小根堆：树结构

就拿小根堆，看下，堆的限定条件 ：

1. 是一个完全二树树
>注：不是满二叉树，是完全二叉树
3. 插入新节点时：一定是从树的最后位置插入
4. 每个子节点\(左右都是\)都要比父节点大

> 挺简单，就3条

分析特性：

1. 因为是完全树，最差结果：最后一层不平衡，且每次新加节点是最后，即：该树肯定是最底层由左往右添加
2. 顺着任意节点向上：肯定是降序的，由根向下的任意路径肯定是升序
3. 根节点的关键值，肯定是最小的
4. 虽然是棵树结构，但是它没有限定左子节点一定大小(等于)右子节点，就不是搜索二叉树，也就是CURD操作更简单，不需要规则限定。

> 结合以上4点来看，实在起来，就一个点麻烦：如何获取最后一个节点的位置？\(插入的时候得先确定位置\)

链表可以实现，但是计算这个最后节点有麻烦，再结合他是一棵：完整二叉树且是一直连续的，没有空的洞，那么：用数组实在更简单

结论：

虽然也是树形结构，但是它的限定条件：相比于搜索二叉树没那么严格，实现起来简单，操作起来也简单，自然速度也更快速，适合一些小场景使用，另外因为是一个完整树的且连续的，用数组容器效率还会更高

1. 可以用来做些极值访问频繁的情况:top k
2. 大部分的实现容器，使用的是数组

删除操作

以删除根节点为例子，删除后，得对树节点做出调整，那么取出最右侧的节点，换到根节点，然后，对原根节点 的左右两个节点进行比对，与大的节点进行换位置，循环此过程

> 它的树调整：是从上而下的

插入操作

以插入最右侧值为盒子，比对树最右侧的值，然后对调，对调后，判断父节点，继续重复此过程

> 它的树调整：是从下而上的

> 之前一直以为是顺序存储，就是个有序数组

应用场景：

1. 排序

> 先弹出堆顶的，然后拿最右侧的值，逐步向上比较，再弹出堆顶

1. top K, 从100万个数中找出最大\(小\)的前k个

> 开设一个堆结构的数组，大小为K来，每次数据有插入/删除操作，即更新此数组，溢出的直接扔掉

1. 中位数

> 有两个堆结构，一个大根堆，一个小根堆，两个根各存一半的数据，即：小根堆的数据均大于大根堆的数据
> 
> 
> 最后，如果集合的元素总数为偶尔时：两个堆的堆顶元素即是中位数，奇数个时，小堆根的堆顶元素即是中位数

1. 优先集队列

# 二分查找



优点：

1. 平均速度：log2

缺点：
1. 所有的数据必须得先排序
2. 重复值的处理，定位一个值，然后向左/右，依次查找，直到找到不等于\<查找值\>的那个
值。所以，比较适合重复值少的情况。

# 线性查找

就是正常的，从容器中依次顺序遍历每个值，然后对比。

优点：
1. 简单，没有太多的复杂算法，不需要太多代码

缺点
1. 搜索速度慢，O(N)


它只能适用于一些小数据量的计算，很初级的算法

算术表达式\-后缀

# 递归算法

> 也叫，数学归纳法。重复一步的操作，循环执行，直到设置一个终止的条件\(否则死循环\)

跟代码执行栈，有点像，一个函数准备开始执行，就把该函数相关变量、常量压入栈中。如果函数在执行过程中，还调用了其它函数，就暂停该函数，将新函数再压入栈中执行。

斐波那契数列 ：当前数=前两个数之和

三角数：N位置的数=N位置\-1的数\+N

阶乘：1 \* 2 \* 3 \* 4 \* 5 .... \* N

汉诺：将几个递归大小的方块，从A柱上移到C柱上，中间借用一个空柱子

字母的全排列：把一个单词拆分成单个字母，计算出全排列

> 以上几个数学题都有那么点递归的意思，但哪个程序员蛋疼计算这些鸟东西，看看下面的实际应用：

1. 树的递归遍历\(前、中、后序\)
2. 归并排序
3. 递归二分查找

所以，递归这种算法更多的是以代码工具类使用

效率：比正常代码要慢

优点：几行代码搞定，略简单，取代循环

缺点：比正常代理效率低，占内存，因为栈不能轻易释放

# 大数据处理总结

大数据不可能一次把所有数据均读取到内存中
所以，先调用外部\-部分存储，分而之治，打散成若干小文件，之后或者 HASH 统计 或者归并排序，再求结果

# 总结

通篇看完，肯定是收获比较大的，对编程思维、软件开发者的理解、对软硬件的更深层次理解，往大了说：对计算机软件/硬件体系的理解都更深。

> 有那么点突然开窍的感觉呢

所以，文章开头也说，这东西是基础中的基础，说它影响着现在全人类的进步也不为过，因为AI、大数据里还有更多的算法，虽然文章都是基础的算法，但这两个体系差不多。这也就引出，为啥大公司面试揪着这鬼不放的原因了

从1946年冯诺依曼发明计算机\(其实图灵更早发明\)，70多年左右，计算机发展的已经非常完善了，各种硬件性能的优化，工业级开源软件的诞生，对于现在普通程序员基本上碰不到这些数据结构与算法。尤其，做互联网开发的，跟硬件没关系，跟大数据、AI也没有关系，最多就是个CURD，且不在大公司工作的，这东西学了，其实用处不大..

就拿PHP举个例子吧：

> 非PHP程序员都鄙视这门语言，尤其搞JAVA的，当然，C语言鄙视一切...

我就觉得这门语言真是把上面的话总结并实践发挥到了极致，如：

静态型语言/编译型语言：缺点，指针、变量强类型、垃圾回收、内存不好管理

在PHP这儿全都解决了

而像他们的优点：大数据的算法

PHP通过了DBMS解决了....

> 另外，还有一些比较LOW的程序，说什么：万物皆协程，吹虚GO有多好，但我就想问：一个进程开100个协程和直接开100个进程，哪个快？不要总盯着一门语言拿优点去对比别的语言的缺点，真正的高手不会局限于某一门语言，而具体应用场景使用具体的语言做开发.

这就是讽刺的，大部分公司程序员日常写代码，也就是自行车级别，但面试让你造火箭.....

各公司非PHP程序员各种鄙视 PHP，但背地里喊着 招PHPER好难，JVM好难搞...

虽然，本人也挺抵触上面的事情，但没办法，还是得看，还是得学，为了更多的money~

索引

http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html

http://blog.csdn.net/v\_JULY\_v/article/details/6530142

http://www.cnblogs.com/xuqiang/archive/2011/05/16/2047001.html

