

# 概览

一堆数字，散落在一颗树型结构上，最顶层就是树的根，也叫根节点，仅一个。下面连接着一堆树枝，然后是叶子，叶子下面还可以继续连接树枝，树枝再连接叶子，一个循环。而数字就保存在这棵树的根、叶子上面。而数字是有一定算法才落在这颗树上的。

一个节点下面，可以有1个叶子，也可以有2个，甚至N个，这就形成了不同的树结构：

1. 二叉树
2. 2\-3\-4叉树

> 具体还是看使用场景，也没有完美的树

## 名词术语解释

|名词     |说明                                                                |备注                                      |
|---------|--------------------------------------------------------------------|------------------------------------------|
|根节点   |树的第一个元素，且只有一个                                          |算是入口节点，像CURD、遍历都得先找这个节点|
|节点     |树中的一个元素，保存着：关键值、数据、自定义的数据，上下左右节点的索引值。使用者CURD操作的实体 |                                          |
|叶子节点 |跟节点差不多，只是它下面不再有任何节点了，有点最终节点的意思        |                                          |
|子节点   |插入元素时，根据关键值，挂在某个节点X下面，该节点就是X的子节点      |                                          |
|父节点   |插入元素时，根据关键值，挂在某个节点X下面，X                        |                                          |
|叔父节点 |跟父节点同层级、同祖父                                              |红黑树中使用                              |
|层级/深度|最终成型的树肯定是一层一层的                                        |时间复杂度、平衡树等都要用这个值          |
|子树     |某个节点下的整棵树                                                  |平衡树会用                                |
|路径     |某个节点到某个节点经常的路线                                        |带权二权树会用到                          |
|关键字   |根据一个关键字，来组织树的结构。如：数字，小的靠左，大的右靠        |                                          |
|数据     |一个节点的核心是关键值，但还可以存其它做生意的东西，比如：一条记录  |                                          |

![[二叉树-基础.png]]
# 根据树的叶子散落情况，分类

1. 满二叉树：一颗辅开后，就是一个‘三角型’，即：所有节点都是有左右节点，左侧跟右侧完全相等，（上面的图就是，超喜欢这种情况，但只是理想主义...）
>这种也叫完全平衡二叉树，搜索肯定是最快的
>但是为了维持平衡，插入的时候会变慢
1. 完全二叉：跟满二叉树略像，区别在于树的最后一层
- 树的最后一层左侧都是满的，右边可以为空
- 最后一层上面必须都得是满节点
1. 非完全二叉树：上面2个条件任意一条不满足即是。





# 树的具体实现

链表，大多都是链表，因为树的结构不是线性，且比较松散，还要维持一定的平衡度，它的插入/修改比较频繁，链表是最适合的。

> 数组也能实现，但太复杂

# 二叉树/二叉搜索树

> BST:binary search tree


![[二叉树搜索.png]]

>搜索次数取决于树的高度，如：树总高度为4层，那么查找一个值，最多需要4次

数字与树的映射关系：当前叶节点保存的数字的左边的值小于当前节点值，右边是大于当前节点值。

## 数组、链表 和 二叉树的区别 

>前置条件：假设有一堆数字，需要一个容器存储，并保持有序

1. 插入时，每次排序过程，都要移动元素
2. 有序链表无法快速定位到一个元素值，必须得顺序全遍历
3. 二叉树查找某一个值速度非常快，配合链表结构，插入也相对快
>二叉树算是对链表的优化，还是链表的有序结构，但是每个节点之间的连接关系做出改变，不用全遍历了


## 时间复杂度

最好情况：如果是平衡的二叉树，O\(log2n\)

最差情况：二叉树，成直线状态，O\(n\)

影响值：树尽量平衡，'深度'，尽量低，因为度决定了时间复杂度。如何影响平衡的条件太多了，如：重复值过多、插入的顺序、数的散列程序等等。

优点：查找一些值时，综合效率最优。

缺点：

1. 平衡性，比如只有左节点那就变成了线性结构了。
2. 重复值，因为只能2个节点，重复值不好处理。
3. 遍历性，这个要比数组 链表略复杂一些。

## 适合场景

参考平衡二叉树吧，因为这东西拿来当\<树结构\>的教学入门可以，但实际使用中，缺点太多。

# 层级计算

深度优先：从根节点开始，往最深的一边找，然后回来，再换另一边（递归）

广度优先：从根节点开始，然后遍历第二层、第三层、循环。（队列）

> 强迫症的同学会觉得：就一层一层的遍历多好，非得绕来绕去的用深度优先算法...还得使用递归...

优缺点：

广度优先：他使用的是队列，得一次保存整层的节点，占用空间大，但是没有回溯操作，略快些。

深度优先：它使用的是递归，不用保存整层的节点，占用空间小些，但是有回溯操作，略慢些

从方向/角度看：

1. 广度优先 给每层打上层号是正向的~也就是 1\(根节点\) 2 3 4 5 ...
2. 深度优先是返过来的：10\(根节点\) 9 8 7 ... 1

深度优先：给每个节点标识层级（降序），同时还可以票房：计算左/右子树高度的

广度优先：给每个节点标识层级（升序）

# 最小值计算

从根节点开始，一直向左，找到最左的那个节点，就是最小值

# 最大值计算

从根节点开始，一直向右，找到最右的那个节点，就是最大值




# 相邻关键字计算

# 树结构的全遍历

线性结构：有头有尾，只需要沿一个方向，移动(遍历)即可。
树结构：根节点、最左侧节点、最右侧节点，可以从3个方向移动

1. 它像是一个三角形，可以从：上左右三个方向做全遍历。
3. 它有层级的概念，还得支持层级的遍历。
>3个方向，对比性线，也等于加了一个维度，复杂也加了一个维度

## 以三角形的方式，从根开始遍历
#### 先序：根左右

1. 遇到一个节点，直接弹出
2. 判断该节点是否有左节点，如果没有，开始找右节点
3. 判断该节点是否有左节点，如果有，找到左节点，并弹出左节点，继续寻找左左节点
4. 直到左节点均找完后，开始再找右节点，重复上面步骤

![[二叉树-先序遍历.png]]
#### 中序：左根右

1. 遇到一个节点，先暂存该值
2. 判断该节点是否有左节点，如果没有，即弹出该节点
3. 判断该节点是否有左节点，如果有，缓存该左节点，继续左左节点
4. 假设当前左左节点没有左左左节点了，那么弹出该左左节点
5. 弹出左左节点的父节点\(左节点\)
6. 判断该节点是否有右节点，如果有，继续重复上面流程


#### 后序：左右根

跟中序差不多，也是先缓存根节点，然后先找节节点，但是，左节点找完后，并不着急弹出根节点，而是再找右节点，直到右节点都找完再弹出根节点

#### 例子

![[二叉树遍历.png]]

先序：HDBACFEGKLGML
>第一个节点肯定是 根

中序：ABCDEFGHIGKLM
>第一个节点肯定是最左侧的，也就是最小的节点，最后一个节点肯定是最大的
>给元素值做了排序(升序)

后序：ACBEGFDGILMKH
>最后一个节点肯定是根


### 这东西有啥用？ 

1. 先序：计算表达式-前缀、打印一颗树
2. 中序：其实是排序\(升序\)。计算表达式-中缀
3. 后序：计算表达式-后缀
4. 持久化到硬盘中，启动时，根据存储的顺序将树结构恢复到内存中
>先序中序后序，在从硬盘中读数据，恢复树，结果是完全不一样的



## 层级遍历

就是按照层级依次遍历，比较简单


# 增删改查-操作

#### 添加
1. 找到那个值应该存放的位置
2. 把原树的连接分开，把新值插进去即可

#### 删除

1. 只有一个元素，删除即是清空
2. 左侧有一个值右侧空 或 返过来，直接删除该值，把唯一的节点提上来
3. 左右侧都有值，从右侧找出最小元素，提升到删除节点的位置

#### 修改
 1. 先执行一次删除操作
 2. 再执行一次添加操作


# 用数组表示树

> 上面的方法大多是基于链表结构，数组其实也可以表示树

按照深度层级依次存，根节点在最前面，两边如果为空的节点，放空值。
>第一个元素值即为头，之后两上元素是左右节点，如果节点为空，数据的元素值也为空且有占位符

优点：查找简单，代码复杂度低，连续的内存空间，有一定性能提升

缺点：

1. 最深的那一层，决定了要放多少级，空的全得用\<空\>值补齐，非常浪费空间。
    如果，非平衡二叉树，且一边非常重，那这空间浪费的就是X2了。
2. 添加/删除 要移动整个数组

使用场景：持久化

# 重复值问题

这种情况，感觉在树里有点无奈。

1. 禁止插入重复值
2. 挂载，一个节点挂下再挂一个节点

两种方法其实都不完美，第1种基本上不可能，产品就先把你干死了，第二种肯定要牺牲掉性能，感觉重复值这种情况并不适合树结构...

# 平衡(排序)二叉树/ AVL


 工具网站：
 >https://www.cs.usfca.edu/~galles/visualization/AVLtree.html

当一棵二叉树：出现倾斜时，如：添加|删除时，会做平衡算法(旋转)，使树相对平衡（深度降低），保证在搜索的时候，速度是最快的。
>树的深度决定了搜索次数

#### 平衡因子\(公式\)：

任意节点：左子树的深度\-右子树的深度 \<= 绝对值\(1\)
>对比红黑树感觉这限定规则好简单...，往往越简单越复杂...

#### 旋转

当出现 差值>=2 的情况，需要进行部分节点旋转
旋转的初衷：把树变的相对平衡（层级变低）

旋转的过程

> 以哪个节点做为支点\(轴\)，这个也没绝对的标准，我的实现是：以中间的那个做为支点

1. 先找到要旋转的3个节点\(也可以是2个\)
2. 从这3个节点中，找到哪个是要被移动的，即：最上面的那个节点，顶节点
3. 如果是右移，那就是顶节点下面的左节点，否则，顶节点的右节点，确定了 次节点
4. 将顶节点向左|右落下，然后挂到次节点下
5. 以上4步骤完成后，其实3个节点的旋转已经完成，下面是收尾，即把新的3个节点重新合并到原树中
6. 原顶节点落下后，要把父指针指向次节点，次节点的父指针改成原顶节点的父节点
7. 原顶节点的父节点的左|右子节点指针，指向次节点
8. 如果旋转后，次节点变成了根节点，同时更新成员变量：根节点指针

> 从上面看，其实，旋转过程中核心用到的节点数是2个\(顶节点和次节点\)，而不是3个

![[平衡树异常.png]]

|  |  |  |
| :--- | :--- | ---- |
| LL:左左型 | 左2右0，右旋转一次 | 以中间节点为轴，最右侧节点落到中间节点下面即可 |
| RR:右右型 | 左0右2，左旋转一次 | 以中间节点为轴，最左侧节点落到中间节点下面即可 |
| LR:左右型 | 左2但第三层是挂在第二层的右边，左旋转一次和右旋转一次 | 这个具体以哪个为轴不好说 |
| RL:右左型 | 右2但第三层是挂在第二层的左边，左旋转一次和左旋转一次 | 这个具体以哪个为轴不好说 |



计算过程就是：

1. 从新插入的节点或刚刚删除的节点出发，向上(父节点)遍历，确定每个节点的左侧/右侧深度
2. 计算出每个节点的左右深度，找出最小不平衡的那个子树的3个节点，
3. 根据此节点，再根据上面的4种情况，做出旋转

换个角度看计算过程：

1. LL RR 最简单，以中心节点为轴，但是 LR RL  比较复杂要计算两次
2. 换个角度看，LR RL 产生的三个节点，不做旋转，也不看成有什么联系，就直接给三个节点做排序：小 中 大，就简单了很多

最复杂的情况：

LR RL  在旋转后是正常的了，但是其节点下面都有子节点，子节点的调整更复杂

![[平衡树-RL变换.png]]

复杂度分析 ：

1. 每次插入|删除，需要计算每个节点的左子树高度与右子树的高度
2. 每次插入|删除，可能会发生旋转

# 平衡树\-红黑树 RBT

> 这里的红黑也可以是黄蓝或是深浅色，没特殊的限定，只是单纯的给节点加上一个附加的属性值，以做区别

![[红黑树.png]]]

这里有一个网站：
>https://www.cs.usfca.edu/~galles/visualization/RedBlack.html

它的限定条件：

1. 根节点是黑色
2. 如果一个节点是红色，那么他的两个子节点都得是黑色
>父结点与子结点不能同为红色 and 红色节点被黑色隔开

3. 每个叶子节点(空节点/外部节点)，都是黑色
>这里不是指普通的叶子节点，是特殊的空节点
>原本认知的叶子节点，又被多加了一层空叶子节点，它是用来做判断是否违规时候用

4. 从一个节点到任意叶子节点或空节点：经过的路径，黑色节点都是一样的。

从规则看，应该关注：

#### 新插入的节点是什么颜色？

假设：插入的全是黑色，必然违背第5条，路径数会变
假设：插入手的全是红色，可能会违背第3条
所以，新节点是红色略好些

#### 颜色冲突后，如何调整？

变色+旋转

#### 当一条路径上的黑色节点数不一样的时候，如何调整？

第二次实现了调整，这一条自然满足


#### 具体调整

节点+父节点+祖节点+叔父节点
>新添加的节点+新添加的节点的父节点+新添加的节点的父节点的父节点+新添加的节点的父节点的右节点

![[红黑树-基础.png]]

>一共就这8种情况


我们现在看第2层，也就是：父节点 + 叔节点，分为两种情况：
1. 全红（变色+祖父递归处理）
2. 一黑+一红（变色+左/右旋转）

![[红黑树-变色旋转.png]]



|父节点|叔父节点|类型|操作                                                |\-\-|
|------|--------|----|----------------------------------------------------|----|
|黑色  |无      |\-  |\-                                                  |\-  |
|红色  |红色    |\-  |父叔均变黑色，祖父变红。祖父变成当前节点，递归此操作|\-  |
|红色  |黑色    |左左|右旋\+变色                                          |\-  |
|红色  |黑色    |右右|左旋\+变色                                          |\-  |
|红色  |黑色    |左右|左旋\+右旋\+变色                                    |\-  |
|红色  |黑色    |右左|右旋\+左旋\+变色                                    |\-  |

插入时判断是否违规的几种情况：

分析：

1. 父节点就一个，且父级没有其它叔父节点，这种最简单，完全符合条件
2. 其余的情况第一个条件就是父节点为红色，这直接就违背了第2条，剩下就是看叔父的颜色了
    1. 红色：父与叔父均是红色，直接递归操作就行，也算是略简单的
    2. 黑色：这种是最复杂的，

另外一个角度看，如果把所有红色节点去掉，再合并一下树，看看...

它其实在旋转上跟高度平衡树的算法是一样一样的，不同的是，高度平衡树得每次计算根及子树的高度值，而红黑树是计算父/叔父的颜色。 另外，当规则破坏后，它除了旋转会多了一步变色步骤。


#### 复杂度

红黑树的查找，插入和删除操作，时间复杂度都是O(logN)
# 平衡树与红黑树 对比

红黑树最大差：一倍
平衡树最大差：1

所以，平衡树对整体平衡度要求高于红黑树，导致它可能会大量的执行平衡操作。

平衡树：删除添加操作较少，适合

红黑树：对整棵树的平衡度要求没那么高，适合

# 2\-3\-4树

> 也叫：多路平衡二叉树
> 数值还是有序的存放：跟 BST 一样，左值肯定小于右值，依次按照大小顺序存于各节点中

| 名词          | 解释                       |
| ----------- | ------------------------ |
| 节点          | 正常往树上挂载的一个节点\(树枝\)       |
| 指针          | 当前节点指向下一层节点              |
| 2\-3/子树/大节点 | 一个大节点/子树可以保存1个值或2个值或3个值  |
| 4           | 3个值，有4个指针，指向下一层          |
| 裂变          | 某个大节点中，插入了4个值，第二个值上升一个级别 |

> 注：这里千万别把节点跟大节点/子树值弄混了，我特意画在表格里了。


它的算法及裂变过程：

1. 查找比较大小，确定了位置后
2. 判断这个节点的值个数，是否=4 ，如果条件成立，触发裂变
3. 从当前节点的4个值中，取整 n/2\(最左侧开始，找出第2个值\)，然后弹出到上一层
4. 将剩下的3个值合并一下
5. 弹出的值，会上升到上一层的节点中，重复步骤上术步骤即可。

>看它的规则感觉好简单。。。比较大小后，插入数据，一但满足4个，就产生裂变，重复这一步

![[234树.png]]
> 裂变≈红黑树变色+旋转≈平衡树的旋转


![[234树完整.png]]

>有趣的是，2\-3\-4树展开后，是可以直接转化成红黑树
一个2\-3\-4树对应\-》多个红黑树
一个红黑树\-》对应一个2\-3\-4树


与二叉树的区别


2345树：

1. 一个大节点可以放多个单节点
2. 一个大节点最多还要放4个指针
3. 平衡算法：分裂/弹出

二叉树：
1. 没有大节点，只要2个指针：指向左和右
1. 平衡算法：计算路径权重

234树需要更多的存储空间，但深度低
二叉树空间少，但深度高


二叉树：log 2 n
2\-3\-4：log 4 n

查找的效率，平均看差不多


总结 ：各种文章书籍没咋标注，我自己也太理解透，感觉这个鬼东西，没啥实际用处... 反倒像是教学DEMO...

# 2-3树

> 跟2-3-4树有点像，区别：

1. 节点的值数量到3就开始了分裂，少了一上节点值数量
2. 它是先插入值再分裂，而2\-3\-4树是先分裂再插入值
3. 因为少保存了一个节点值，它的尝试要比2\-3\-4树略主同一些


# B-树

规则：
1. 每个节点最多有M个子树
2. 根节点至少有2棵子树

![[b-tree.png]]

它就是一棵 2-3 / 2-3-4树，只是做了一个简易升级：
1.  节点中除了保存关键值，还其它用户自定义的数据
2. 节点更多，可能是 2-3-4-5 
>具体看使用场景 

优点：

	1. 多路树，压缩了树的高度，减少了查找时的对比次数
	2. 关键值+数据，最快：一次磁盘IO就够了（一条数据压缩成个 BLOCK ）

缺点：

1. 一次 IO 读取的索引数据不太多(还要读DATA)，磁盘IO还是略高些
3. 范围性查找，如：18<年龄 <60，不太好查找，IO次数还是很高
4. 如果 DATA 过大，会挤压一个硬盘的 block 空间，最差结果可能一个节点只能保存一个子节点，又恢复成二叉树了



删除操作：索引肯定得重新调整位置 ，但是 DATA 的文件存储，只需要找到那条记录，打个删除标记就行了\(回头统一真删除，或者干脆就把新记录覆盖到这条记录上\)

插件操作：索引肯定得重新调整位置 ，但是DATA的文件存储，直接到文件尾部，插入即可

缺点：搜索数据，至少要进行二次操作，第一次是走索引，假设最好的情况第一次即搜索命中，但是要获取真实的数据记录，还得再根据索引值，再去硬盘中取一次。

另外，顺序存储还有个问题，多索引咋办？用b\-tree 可以建立其它类型的索引，但是最终DATA存文件的格式是不能变，范围查找肯定还是慢，但没太好办法

# B+Tree

> 算是对 B-Tree 的升级，所以 才有一个加号

非叶子节点：不存数据，只存关键值+数据的指针
叶子节点：存储具体数据

![[b+tree.png]]

与B-Tree区别

1. 非页子节点不放数据：一次可以读出更多的节点（索引数据），搜索更快
2. 页子节点存放的数据，可以再串到一起，做：排序、范围查找


分析：整个数据落在硬盘后，前部分都是索引\(关键字、指针\)信息，剩下的大部分都是真数据，而这些数据落到叶子节点上，以中序遍历的角度看，就等于是顺序存储了，但得把叶子节点再加上个指针横向完全链接起来


# 磁盘与内存的读写


#### 内存快于硬盘

1. 内存是直接寻址，大概1微秒
2. 硬盘得通过磁头寻址，大概10毫秒\(但真正的IO是毫秒级，只是寻址慢 \)

> 相差了大概10000倍\(1毫秒≈1000毫秒 \* 10\)，不过SSD的出现还是提升 了不少的


#### 硬盘IO

一次IO最小单位是：block。它的大小由OS决定，肯定是2的N次方

> OS一次硬盘 的读取是一页，≈N个block

#### 树与硬盘/内存

理想状态下，当然是我们的整棵 树 都装进内存中，就可以完整该树的所有功能。
但有些情况 ，是不行的，如下：

1. 数据库，本就是装数据的地方，肯定大，就算OS上所有进程都让路给数据库，但也不可能把所有数据全加到内存中
2. 假设每个用户都要用到一颗树，当前有上万个用户，因为每个用户的树都不同

所以，当整棵树无法全放到内存中计算时，就只能每次读硬盘的部分 树 的数据到内存中

#### 顺序存储

一条记录，根据 一个关键值 \(索引值\)，如：ID 或 NAME ，顺序存储在硬盘 上

假设：一个 block 的大小是 1024 bytes，一条记录的大小也是1024bytes,OS一次硬盘IO是1024byte。
那么 ，100条记录就需要100个block存储

查找 ：

1. 单条记录的长度，块大小，可以计算出一个块存多少条记录
2. 一共有多少条记录，能计算出有多少个块
 
 
根据已上两点，可以使用二分查找，硬盘 IO次数是log 2n

添加/删除 ：这个就是灾难 级别了，因为是按照顺序存，一但顺序发生改变，要移动所有 block 的记录

另外：某信集合，如果只是按照一个索引来IO还好，如果有多个呢...

如果使用普通 二叉树呢？查找 跟上面差不多，添加删除略好点，但是取地值 时没有顺序存储 的快

使用B\-tree

> b\-tree \+ 顺序存储 组合

每一个块中除了关键字\+数据，还多了指针，虽然占了点空间，但是每了个节点里的关键值变多了，减少了IO次数

# 总结 

|  | 最好 | 最差 | 平均 |  |
| :--- | :--- | :--- | :--- | ---- |
| 二叉树 |  | O(N) | log2n/2 |  |
| 平衡树 |  | log2n | log2n/2 |  |
| 红黑树 |  |  |  |  |
| 2-3-4树 |  |  |  |  |
| B+Tree |  |  |  |  |
| B-Tree |  |  |  |  |








