
# uuid
## 概览

uuid：Universally Unique Identifier 通用唯一标识，是为分布式系统生成不重复的唯一值，极端情况也会有重复的情况。

作用：生成一个唯一标识码，尤其在分布式系统中，不依赖中心来生成（没有网络请示），本机即可生成

优点：
1. 不依赖网络，在单台机器上即可生成
2. 速度快
3. 不依赖语言，统一算法即可

缺点：
1. 占空间，32个字节，存储麻烦，传输麻烦

## 规则

总共36个字符：数字+16进制字母(a-f)+中划线
总共是128 bit = 128 / 8 = 16 bytes = 32个字符(两个16进制字符=1个字节) + 4个中划线字符=共计36个字符


>其中：中划线是分隔符，没实际意义，但占了4个字节，实际有效的位数是32个16进制字符(16个bytes)

格式 = xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
格式长度=8-4-4-4-12


格式中的字母M和N：

M：代表版本（包括：1、2、3、4、5）
N：代表最高有效位表示，只有 8,9,a,b


32个字符的规则：它有5个版本

1：date-time & MAC address
	- 15 ~ 13 = 4bytes = 时间值低4bytes
	- 11 ~ 10 = 2 = 时间值中位
	- 9 = 4bit + 4bit = 版本号 + 时间值高位4bit
	- 8 = 时间值高位
	- 7 = 变体值 2bit + 时钟序列
	- 6 = 时钟序列
	- 5 ~ 0 = (节点值)mac 地址
	>7.5个字节表示时间，精确到ns'
	>6个字节填充mac值(也可以用随时值替换)
	>4bit + 2bit 版本信息
	>8bit + 6bit 时钟信息
	>精确到纳秒级别，重复率应该非常低，但有专家说 mac 地址被漏了，不太安全
2：date-time & group/user id
	- 跟上面差不多，但是原先7.5个字节表示时间，改成了3.5个表示时间，剩下4个字节用来表示  gid/uid
3：MD5 hash & namespace
	- 不用时间和机器信息，用：命名空间（类似1和2的UUID） +  名称（uname/uid/gid） ，再用hash函数做次加密
4：pseudo-random number
	- 纯靠随机，但得注意下算法，减少重复率
5：SHA-1 hash & namespace
	- 跟3都差不多，用  sha1 函数做次加密

## 分析 

这个值要存储，可能还还要传输，甚至可能还要明文传输，那么这里有2个问题，且是矛盾：
1. 该字符串要有意义
2. 考虑安全

版本1：字符串是比较有意义的，但是它把 mac 地址露了
版本2：算是对版本1的加强，多一个字段，字符串更有意义了，但依然会 把 mac 地址露了
版本3：hash 加密后，就不露了，加密有一点小浪费时间，且有碰撞的可能。但又违背了 字符串 有意义
版本4：就是硬随机没啥固定逻辑，安全、计算时间都兼容了，但还是 违背了 字符串 有意义
版本5：跟3相似，但 sha1 的加密更浪费时间

综合看：版本4是比较全面的，即安全（不包含：mac地址、IP地址、gid、UID、重复率低、没有碰撞、时间信息等），又没有计算时间（hash/md5、 sha1）。

>重复概率：0.00000000006
（ps:具体计算重复概率的公式自己查吧，不上传了）



样例：
>
78243022-b787-4df4-9f12-c1c054810a32
e2613f46-2af9-4a50-bc04-b79ef7e5ddd5
5b4fd027-09b8-4ae9-8332-e19e39842cee
337c849c-b178-4bd4-b7ce-51b746dd7175
d6758fe1-d8c1-4ac8-83de-33fde7e59f3f

linux:快速生成一个UUID
>cat /proc/sys/kernel/random/uuid

## guid

guid：Globals Unique Identifiers，全局唯一标识。由微软提出来的

格式：8-4-4-16

具说唯一性更好，且在WIN系统内大量使用，如：注册表的KEY值、机器名、数据库等等吧

## 小结

uuid只是一种算法(协议)，不一定非得按照它的规则来，也可以用变种算法，如：雪花算法 。

具体还是看使用场景：
- 只是单纯的想一个唯一随机字符串 uuid4，用它很适合
- 我更倾向于用版本2，虽然有暴露的风险，但一堆无用的串，又有何用？好歹加个时间进去吧

# base64

1. 把字符串 转换成： ascii 对应的 数字
2. 把数字转换成2进制
3. 所有的2进制数，以6为分隔（最后，不足6位补0）
4. 每组6位的二进制数再转成10进制（6位二进制范围就是：0~63）
5. 拿出 base64 映射表，把新的数字映射出来即可


![[base64.png]]

>URL传输过程中，会对特殊字符进行转义，如：\\ \+ = ，所以，转完了BASE64，还得针对这3个字符再处理一下。

用途：
1. 加密（不过属于 对称加密，也可以破解，且是最基础的加密 ）
2. 传输过程中特殊字符，如：\t \n 等，base64 可以显示

base64:是一种编码格式，不是用来加密的。传输大点的东西，像：图片就用base64更适合些


# 布隆过滤器

一个文本文件里，存了10W条 URL 地址，此时判断某一个地址是否存在

1. 最笨的方法，遍历10W条记录。时间 + 空间 都是浪费
2. 用 hashMap 存，空间还是浪费


![[布隆过滤器.png]]

用 bitmap 存，减少空间。再选择 N个 hash 函数，减少计算时间

1. 如果查询结果都为1 ，此值可能大概率存在
2. 如果查询结果有一个0，是肯定不存在的


布隆过滤器的缺点：

- 不存储数据本身，所以只能添加但不可删除，因为删掉元素会导致误判率增加
- 由于存在 hash 碰撞，匹配结果如果是“存在于过滤器中”，实际不一定存在
- 当容量快满时，hash碰撞的概率变大，插入、查询的错误率也就随之增加了


优点：本就是大数量，有1个错误的不太影响，但是空间、计算性能可是非常高的

这里的重点是：hash 函数的选择，以及 hash函数的个数


 布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。




