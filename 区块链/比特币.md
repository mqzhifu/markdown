# 概览

2009 中本聪 开发出了比特币\(区块链\)，到现在 2021 年，也运行了 12 年了，很稳定。

> 目前没人知道中本聪是谁，很神秘。
> 学完比特币，感觉这哥们算是个天才吧，不是智商多高，而在计算机领域、金融领域很强，完美的虚拟出一种货币，每个环节都考虑到了人性的贪婪......

## 什么是比特币 ？

比特币是一个软件系统，也可以说是一个协议。大家使用这个软件，实现了：点对点的虚拟货币交易。

> 实际并没有货币这个东西，也没有区块链的这个概念，后续介绍大家即会理解。

## 什么是去中心化？

人人都可以参与，没有公共 server，任何参与的人，即可以是客户，也可以是提供服务方

> 也可以理解为分布式，如：zookper、consul、etcd

# 产生的初衷

假设现在我们有一些数据，比较关键，如财务报表，怕人做假账、篡改，于是：

1. 给这部分加密，但数据还要可见。给这部分数据加一个数字签名:hash\(data\)
2. 数据加完签名后，拥有者还可以随意更改，这个时候还要公开，任何人都可以下载。
3. 这个下载地址如果是单点的，会有挂了的可能，于是引入分布式系统，人人可以参与，人人可以下载。

最后，上传数据的人，最好得有个账户系统，但是我们想要匿名的，于是就有了本地生成账号功能

感觉好简单，分析下来看，几个核心的技术点：

1. hash 函数加签名
2. 数据库
3. 分布式网络
4. 本地生成匿名账号\(公/私触\)

对应比特币里的术语就是：

1. 区块，用来存数据
2. 区块链，将每个区块上的数据连接起来
3. 交易，将数据打包发送给其它节点，其它节点验证后，就把数据最终写到区块上
4. 网络/广播：将交易的信息发送给全网，让其它节点验证。发现其它网络节点，从其它网络节点拉数据等
5. 地址/账号：就是生成匿名账号

# 比特币中常用的几个 hash 函数：

1. 比特币使用 SHA\-256 和 RipeMD160
2. 两次 SHA\-256=hash256 或者 dhash
3. SHA\-256，再计算 RipeMD160=hash160

# 广播/网络/整体流程

> 先从 github 下载代码

新节点启动后：想要参与全网，得先发现至少一个网络上的任意节点\(正常\)，并建立连接，且要连接成功。

> 协议使用 TCP，8333 端口。

如何发现节点？

1. 本地维护一个种子节点列表
2. 启动时，给程序指定 IP

> 注：可以同时建立多个连接，不过，这个连接数没必要太多，浪费资源，保证有 2\-3 个够用了。

1. 连接建立后，简单的通信发包收包，确定都 OK 后，才算正常启动成功。被连接的节点，会把你节点的信息，再同步给其它节点，这样一个大网络就形成了。
2. 启动成功后，你也可以向已连接节点询问要其它对等节点的 IP，然后断开这个连接，再连接这些对等 IP
3. 任何节点又可以随时离开，如果你连接的节点突然断掉，你得赶紧再找一个新节点

> 每次启动连接成功的 IP，它会记在本地，下次再启动的时候，也可以拿出来用，即：种子节点
>
> 已建立连接的节点，双方对定期做个心跳~发个包之类的。如果超过 90 分钟无包，断开连接

总之，感觉比特币的网络很松散随意自由

> 节点是扁平化的，没有所谓的国家地理之分

广播交易：轻节点将交易信息打包好，发送到其它节点等待确认

广播区块：节点挖到了一个新节点，发送其它节点等待确认

整个交易广播流程：

1. 轻节点/客户端:将交易进行打包，然后，推送到邻近\(已连接节点\)的网络中,3\-4 个节点，包名：InvPacket/TXPacket
2. 邻近节点接收到此消息，向客户端发送：GetDataPacket，接收 TXPacket
3. 邻近节点对这笔交易进行验证，如果验证成功，将该交易加到自己的内存池\(交易池\)中，存储所有未被确认，未能写入到区块链中的数据。
4. 矿工会对这个池里的交易进行排序，比如：小费高的靠前，之后，统一选择一批交易，大概 1M 左右，开始进行挖矿。
5. 如果这期间，有其它新区块被发现，你拉回来数据，对比后，发现当前挖矿的交易列表中有相同记录，那么就可以剔除了，更新列表，重新挖。

这期间，也有可能别人挖出新块，需要你确认的。

会不会出现：A B 同时计算出新块，且同时被网络上其它人确认，即：两个新块均是合法的~那么就出现分叉了，

# 区块

一个区块=header\+body

> 跟 http 有点像，头里加个属性描述信息，体里是具体的数据.一个 body 最大：1MB 左右

## header

| key              | desc                                                       | len\(bytes\) |
| ---------------- | ---------------------------------------------------------- | ------------ |
| hash             | 区块哈希                                                   |              |
| Version          | 区块版本号                                                 | 4            |
| pre\-hash        | 上一个区块哈希                                             | 32           |
| nBits            | target\(难度目标\)                                         | 4            |
| root Merkle hash | 数据被分成多段字符串，每段字符串进行 hash，最后再汇总 hash | 32           |
| Nonce            | 每计算一次 hash,累加 1                                     | 4            |
| timestamp        | 该区块的产生时间                                           | 4            |

## body

|                |             |
| -------------- | ----------- |
| Transaction\-1 | UTXO1 UTXO2 |
| Transaction\-2 | UTXO1 UTXO2 |
| ...            | ...         |

> body 里牵扯的是交易部分后面讲，这里先分析下 header

hash 值就是此区块的唯一 ID 标识

> hash 值=hash\(header 里面每个字段的值\)

pre\-hash 字段:分析看，类似链表的指针\(这里是 hash 值\)，也就是把若干个区块通过指针连接起来，感觉就是区块链的意思....

> 具说原本没有\<区块链\>的概念，只是因为是有点像是链表才有这个词

# 挖矿

> 从上面看，一个区块也没什么特别的，就是简单的结构体，有点 DB\(kv\)的意思

给一个区块计算出一个 hash 值。看着其实挺简单，hash 值=hash\(header 里面每个字段的值\)

为什么挖矿特别慢呢？因为它得遵守一个公式，如下：

计算一个区块链的 hash 公式：

> SHA256\(SHA256\(version\+hashPrevBlock\+hashMerkleRoot\+ timeStamp\+ target\+ nonce\)\) \<= target

分析公式：右侧并不是等于号，而是\<=target，所以想一次 hash 实现不成立。那么，复杂的是 hash 值得满足 target 限定。

> target = target_max / difficulty

difficulty:难度系数

target_max:一个常量

> 很明显 difficulty 值越大 targete 值就越小，而值越小，进行 hash 碰撞需要的计算量就越大

分析公式：这里除了 nonce 都是固定的，那么 nonce 就肯定得是一个随机数，通过随机数改变最终的 hash 结果，而这个随机数就是消耗时间，需要计算的关键点。

而计算 header hash 值就是：sha256\(header hash 值 \+ Nonce\)

> Nonce：从 1 开始，每次累加 1

所以，挖矿就是：计算 Nonce 值\(hash 碰撞\<=目标值\)

接 targete， 值越小，前面的 0 就越多，而正常在计算 header hash 值时是随机的 0~9 a\-f 组成 ，能在最前面出现两个 0：44

1. 3 位是 0 的哈希值，理论上需要计算 163=4096 次，实际计算 6591 次：
2. 4 位是 0 的哈希值，理论上需要计算 164=6 万 5 千多次，实际计算 6 万 7 千多次：
3. 5 位是 0 的哈希值，理论上需要计算 165=104 万次，实际计算 158 万次：
4. 6 位是 0 的哈希值，理论上需要计算 166=1677 万次，实际计算 1558 万次：

> 17 位 0：2.9 万亿亿次

所以，影响计算次数的关键就是：target ，而 POW 就等于：Nonce 值

最终验证其它人计算出来的 hash 值是否合法的公式：

> 新计算出来的 hash 值 \< target

Target 每两周调整一次

比特币的一个 hash 值

> 0000000000000000000fbb90ac16fce1fa83d6908005548781a91c840fa10f17

为什么非要有个计算 nnoce 过程？

> 如果过快的产生结果，导致整体的计算会产生顺序性的混乱（保证广播到其它节点同步的顺畅），于是就加了个 target 值，简单说就是：你计算出来的 hash 值得满足一定的规则，如：前面必须得是以 0000 开头的...这就麻烦了，只能穷举了~

POW:Proof Of Work,工作证明，就是上面寻找的：nonce 值

# 新的区块产生

当某一个节点计算出了符合条件的 hash 值后，将本次计算结果，发给邻近节点确定，超过 6 个节点确定没问题后：

1. 一个新的区块产生
2. 系统会奖励该节点 N 个比特币\(那么大家就都去挖矿了\)

每个区块都是动态生成的，在没有想要记录的数据前，区块是不存在的。只有：需要记录数据时，才会有人挖矿，才会有新的区块产生

> 这个挺好，用多少产生多少，没必要存到区块上的数据就不要传。

## 几个基础问题

为什么要把数据记录在区块上？

答：它能保证绝对公平，谁也不能窜改，也不会丢失。所有的计算过程都是公开的，且被固定数量的节点确认过的。

公网上的人如何确定？

方法 1：以接收时间为确认，那就是拼网速了，略有点不公平，
方法 2：设计一个复杂的公式，最终看谁的机器配置高，计算能力强，同时再加上一点随机性，这样公网确认的机制就相对完整了

> 这也是为什么要挖矿，空算 hash 碰撞的原因之一

如果需要复杂的计算，公网上的人为什么帮你算？
于是就给了奖励：比特币

那比特币到底能买什么东西？

好像买不了啥，它就是个虚拟数字串，但是，当越来越多的人参与，想把越来越多的数据都记录到区块上，就得付佣金，而系统里如果只允许使用比特币做为佣金，那么，比特币看来也有点用。可依然没太大的作用，下面接着分析。

什么样的数据需要记录在区块上？

其实什么都可以上传，但因为可能要花佣金，那么，隐私（日志 视频）的数据就没必要传了，所以总结下来：财富相关的才值得上传。如：

1. 小明给了我 10 块钱
2. 我给了小明 10 块钱
3. 我买了一套房子 A

这里有两种物体：10 块钱 和 房子

因为区块上任何人安装完程序，都可以任意上传，这个时候 B 上传了：

1. 我还了小明给我的 10 块钱
2. 我买了一套房子 A

虽然 B 传了的是正常的数据，但是 B 其实并没有给我 10 块钱，只是他自己胡乱记的，那么，区块链中的内容看来让用户随便记录就不太行了。得保证绝对财富的公平 。

比如：房子这个东西，你得保证唯一，A 的房子卖给了我，B 就不能再向 A 买了，B 得找我来买。同样，B 在没真的付钱之前，也不能卖 A 的房子
比如：10 块钱，我付给了 B，我就不能再花这 10 块钱了。

分析下来，无非就是需要给一个财富做成唯一属性，被 A 买完，卖的时候也只能是 A 可以。现实生活中很多东西不可能唯一 ，比如：各国的货币，名义上是有编号 ，实际上普通人印不了钱，政府完全可以偷印出两张 ID 一样的纸币。

所以，最终还要绕进来，使用比特币。因为它绝对公平，每产生一枚货币，需要经过全网确认，那么买卖东西，就使用这种货币就行了....
其实，对于使用者的核心诉求：把自己的数据记录到区块上。而，如果想要使用此功能就得花些钱，就得按照比特币的玩法，使用它自创建的一套货币体系。

# UTXO

Unspent Transaction Output：未花费的交易输出
直译过来有点别扭，我的理解：每一次付款产生的记录，最后统计每条记录的收款人的金额，就计算出一个账户的余额。

假设 A 当前有 10 个比特币 ，现在要向 B 买一杯咖啡需要 2 个比特币，生成 UTXO：

| input                 | \-\> | output          |
| --------------------- | ---- | --------------- |
| A 转 8 个比特币给自己 | \-\> | A 有 8 个比特币 |
| A 转 2 个比特币给 B   | \-\> | B 有 2 个比特币 |

> 统计 A 的账户余额，其实就是统计 output,这里 A 还剩 8 个，B 有 2 个

假设，这个时候，B 想向 C 购买一袋咖啡豆，需要支持 1 比特币

| input                 | \-\> | output          |
| --------------------- | ---- | --------------- |
| B 转 1 个比特币给自己 | \-\> | B 有 1 个比特币 |
| B 转 1 个比特币给 C   | \-\> | C 有 1 个比特币 |

> 付款的时候，就是拿上面已有 output 输入到 input

分析看：所有的交易记录，形成了一个链，都可追溯到源头。

一个比特币的源头：是挖矿时产生的，也就是 coninbase，而第一个比特币就是中本聪的：创世区块上面的了.

假设，这个时候，C 想向 D 买一公斤咖啡豆，需要支付 0.01 个比特币，本地将该交易打包发到网络上，发现迟迟没有响应，这个时候它加了点佣金：

| input                    | \-\> | output             |
| ------------------------ | ---- | ------------------ |
| C 转 0.98 个比特币给自己 | \-\> | C 有 0.98 个比特币 |
| C 转 0.01 比特币给 D     | \-\> | D 有 0.01 个比特币 |
| C 转 0.01 比特币给未知人 | \-\> |                    |

这里 input=1 比特币 ，而 output=0.99

多出的的 0.01 比特币就会被矿工以\<贪婪模式\>吸收，并最后这笔转账的未知人写成矿工自己\(前提该矿工挖矿成功\)

这里有个问题，如何计算一个账户的余额？

1. 如果是一个新账号好说，所有都是新的，有进账就直接记录，有输出，也记一下
2. 非新账号，且本地没有任何 UTXO 记录，那么就得去遍历整个区块链的数据了，并且因为没有公钥地址，就只能拿当前账号去碰撞整个区块钱链的数据

# 交易

A 转 B 10 个比特币，钱包会创建一条交易记录，然后再创建 UTXO

input : A 已拥有的 output

output: 转给 B

将 UTXO 合成进这条新的交易记录中，打包生成一条完整的交易记录，然后将这条记录发送到网络上

网络中的某个节点，会拿到一堆类似的交易记录（不仅仅是 A 转 B 这一个），然后挖矿，创建一个新的区块

矿工在把这些交易记录写到新的区块中时，同时添加两条新的 UTXO 记录，

1. 本次挖矿一但成功赚多少比特币
2. 佣金

然后，矿工，打包所有交易记录，开始挖矿，计算 HASH 值...

详细，要做一笔交易分为三个步骤：

1. 构建原始交易记录 RawTransaction，包括：汇总信息，完成的 output 和完整的 input，但是没有签名，也就是没有设置 SignatureScript 的内容。
2. 用私钥对签名构建的 RawTransaction 进行签名，并将签名构建成完整的解锁脚本，填入对应的 Input 的 SignatureScript 字段中。
3. 将签名后的 Transaction 发送到 P2P 网络中。

一条交易记录，格式：

|          | 解释       | bytes |                            |
| -------- | ---------- | ----- | -------------------------- |
| Version  | 版本号     | 4     |                            |
|          | 输入计数器 | 1\-9  |                            |
| TxIn     | 交易输入   | 不定  | 是一个数组，可以包含多条   |
|          | 输出计数器 | 1\-9  |                            |
| TxOut    | 交易输出   | 不定  | 是一个数组，可以包含多条 µ |
| LockTime | 锁定时间   | 4     |                            |

交易输入

| key             | 解释     | bytes |     |
| --------------- | ------ | ----- | --- |
| Hash            | HASH 值 | 32    |     |
| Index           | 输出索引   | 4     |     |
|                 | 解锁脚本大小 | 1\-9  |     |
| SignatureScript | 解锁脚本   | 不定    |     |
| Sequence        | 序列号    | 4     |     |

交易输出

| key| | | |
|--------|------------|----|--|
| values |总量/金额 |8 ||
| |锁定脚本大小|1\-9||
|PkScript|锁定脚本 |不定||
 
一个交易\-\>多个 input

一个交易\-\>多个 output

一个 input\-\>多个 output

多个 input\-\>一个 output

一个交易，可以有 N 个 INPUT 和 OUTPUT，神奇的是交易的时候，从来就没有看到真正的比特币参与，最多就是一个数字。所以，根本就不存在比特币这种货币，只有一条条 UTXO

上面只是构建了交易的基础信息，那如何证明我的 input 是属于我的？接收者又如何确定只能自己才能接收？

这里用到两个点：

1. 签名
2. 公钥/地址

付款方在 OUTPUT 上设置锁定脚本

新交易的 input 肯定是之前的 output,记做：pre\-output,现将 pre\-output 的信息，复制到新的 input 中

pre\-output 这里面肯定带有一个锁定脚本，我们这时候创建一个解锁脚本，然后顺序执行这两个脚本

锁定脚本包括：几个字符串\+操作码

解锁脚本包括：是两个字符串（私钥签名\+公钥地址）

将两个脚本合并 ，把解锁放在上面，再准备一个栈，开始执行：

解锁脚本放在前面执行，也就是将两个字符串压入栈中，然后开始压入锁定脚本，流程过，大概是：

解锁中带的数据：公钥，通过 HASH 函数能推出地址，就证明这个公钥跟地址是相等的，证明确实是收款方

解锁中带的数据：私钥签名，再用公钥解销这个签名，看是否正确，就证明：公钥也是没问题的

加锁的时候就是把这个流程反过来

好像只是填写了对方的地址....其余的是常规 hash 函数...

所以，从这里看到地址到底有什么用了.

解锁脚本\-\>ScriptSig

锁定脚本\-\>scriptPubKey

# 传输

计算出来的 hash 串，得通过网络传输给参加的玩家（N 个人），最后再传回公链上。那么，两个关键点

1. 好的网络
2. 计算块的元数据较小

传输的速度也就过快，被上传到公链上的概率也就是越高
比特币是由发掘新区块的计算过程中产生，也就是说 区块链 约等于 比特币 ，或者说 区块链是底层实现技术，而比特币是区块链技术的上层应用程序。
分析整个流程，好像共赢，想要记账上公链的人，只需要把数据抛出来，而矿工虽然耗费电力 CPU，但是还能拿到虚拟币，看着皆大欢喜呢...\(费解~\)

# 问题

双花
分叉:网络上同时可能有多次交易，需要多次进行 HASH 验证（挖矿）
手续费

# 钱包

私钥：随机生成一个数字，256 个二进制位（2^256），64 个十六进制字符
公钥：由私钥导出
地址：公钥导出，数字\+字母，以 1 开头，58 个字节

```mermaid
graph LR

256位随机数 -->私钥
私钥 --> |SECP256K1|公钥
公钥 -->|sha256| 公钥hash值1
公钥hash值1 -->|RIPEMD160| 公钥hash值2
公钥hash值2-->|添加一个字节0x00|版本号+公钥hash值2

```

```mermaid
graph LR

版本号+公钥hash值2-->|两次sha256|字符串1
字符串1-->|取前4个字节|校验码
版本号+公钥hash值2+校验码-->|base58|钱包地址

```

地址到底是有什么用？

底层技术是给 UTXO 交易时使用，正常理解是：一个账户名

因为这个账号是经过各种加密函数生成，所以一但丢了，不可逆，即：丢失后，所有比特币一并丢失.

keystore:防盗，给私钥再加密一次，生成新串，加密时设置密码

密码：防盗，解开 keystore 成正确的私钥

助词词：防盗，设置几个词，然后转换出正确的私钥

所以，看上面的核心就是：私钥，而钱包就是帮忙管理私钥的一个指令行转 UI 的工具箱。它帮忙你省略了：各种函数，生成私钥，私转公，公转地址的过程。同时有一个忘记私钥的功能...

# 节点类型

一个节点\-包含模块：

| 模块名     | 说明                                                                                         |
| ---------- | -------------------------------------------------------------------------------------------- |
| 完整区块链 | 就是整个比特币所有的区块信息，大概 250G 左右，首次启动，要从其它节点下载到本地，有点占硬盘哈 |
| 钱包       | 打包交易，发到公网，接收确认消息等                                                           |
| 矿工       | 接收其它人发送的交易，打包，挖矿                                                             |
| 网络路由   | 提供些网络广播的操作                                                                         |

> 因为这东西必须得用网络，所以 网络路由肯定是公共模块

全节点：钱包，矿工，完整区块链数据，网络路由节点

> 并没有绝对的 server，一个节点即可以像客户一样发起交易，也可以像太工一样，去挖矿，因为它本地就有所有数据。

轻节点：SPV，网络路由节点。只保存了与自己相关数据的 header 及相关的 body

> 我们日常下载的钱包，基本就是轻节点

矿工：矿工，完整区块链数据，网络路由节点

> 其实也不一定用完整的数据，可以调用 3 方，最后只执行挖矿的功能媃中,上面属于独立矿工

两个暂存服务器：pool stratum

具说，现在大概有 7000\-10000 个全节点，也就是说：一条交易，最终会被这 10000 个节点所记录。

# 挖矿奖励与佣金

我刚接触的时候觉得，SB 才会给佣金，因为矿工本就有奖励为毛还给小费？

但，当挖矿比较容易的时候，佣金好像没啥鸟用，但现在产出一个新区块的概率太 TMD 低了，而且，越往后越低，到最后就没有了。这个时候，光靠系统的奖励对矿工没啥动力，还得支付点额外的小费。

前 21W 个区块，每次挖矿奖励是 50 个，之后是 25，然后是 12.5 个....最终：只会产生 2100W 个比特币

分析看：当产出新区块的概率越低，佣金就会越高

# 总结

## 从技术角度看它的核心：

1. 数据库(k-v)
2. 防篡改(hash 函数)
3. 去中心化（点对点、分布式=\>TCP）
4. 溯源(链表)
5. 匿名(不用生成账号)
6. 公开

## 从政府角度看优点

1. 洗钱
2. 假账
3. 贪污

区块链的两个核心技术点

1. 匿名：根据特定函数随机生成个串字符串，约等于 UID，无须验证，无须注册，无须联网，也就是无法追踪...
2. 无法篡改：所有数据通过加密，谁都无法改

公有链：完全公开，

许可链：某一个领域的，对隐私保护较好，成本低

https://tokenview.com/

https://btc.com/
