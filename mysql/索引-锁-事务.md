http://blog.codinglabs.org/articles/theory-of-mysql-index.html

# 索引

通过一些算法，加快原有数据的搜索速度
>也可以理解为：在现有数据基础之上，增加一种搜索算法

## 索引算法

算法：HASH、二叉树、平衡树、黑红树、234树、B-tree 、B+tree等。

算法有很多种，具体得看数据结构。数据库有个特性：数据量大，内存不可能完全装不，大部分都存于硬盘中。

既然是硬盘，就牵扯到：磁盘IO（磁头寻址），那，好的索引不仅算法好，还得兼容硬盘这个特性，于是B+Tree更适合数据库索引。

二叉树、红黑树 只有2个节点，一次IO，只能读取两个节点，如果不满足就得继续IO一次磁盘，所以不适合，B-tree 有多个节点，这样一次IO可以读取出更多的节点。

另外，根据XX定理，如果磁盘在读取一块数据的时候，邻近的数据，也大概率会用，所以一次IO是把附近的数据也读了出来，如果是聚集索引，页节点间的横向读取，会更快。

## 数据与索引存放：聚集、非聚集


#### 聚集

B+tree 索引建立完成后，最终的叶节点上，会接着存具体的数据。
数据的存储，就是索引的顺序存储，而不是顺序存储。

如：按照 ID 建立聚集索引，最终物理存储，肯定是根据ID来存数据的。如果有删除或者修改，该物理存储就得移动。

优点：
- 数据存储是按照 ID 存放。如果是ID范围性查找，找到第一个满足的，顺序读取后面数据就OK了，IO次数少。
- 页面结点直接连接数据，一次查询就能直接定位到数据。

缺点：
- 修改/删除 慢，因为他是根据ID物理存储的，如果删除一个ID，那整个物理存储的顺序就得动。
- 如果查找时，不是ID，查找，那么查找到的值，最终还是要被转化成ID
>辅助索引最终的值，保存的是聚集索引的引用。

#### 非聚集

B+tree 索引建立完成后，最终的叶节点上，只存具体的数据的地址引用
真实的数据存放，在另外一个地方。存储顺序：就是按照时间顺序存储。

如：此时删除ID为5的，物理存储不动，打删除标志。这时候再插入个ID为10，可能就会放到已删除5的位置。也就是说：物理存储跟 ID 大小没有任何关系。


优点：修改/删除 数据时，没太大影响。

缺点：
- 所有查询，至少二次IO，一次是从索引里面找到记录的引用，二次是取真实的数据。
- 范围性查找，略慢，因为数据不是按照ID排序存，如果按照ID 范围查找 ，数据可能过于分散


应用场景分析：如果范围性、连续性较多的搜索，可以用聚集索引。但如果更改略频繁，还是非聚集索引更适合。

## 索引分类：主索引、辅助索引

实际上，就是数据在物理硬盘的存放顺序，然后做分类。

一条记录存到磁盘上，肯定得有个存放的标准，且只能有一种。如：按照插入时间顺序存储、按照 ID 存储。言外之意就是：数据结构基本上确定了，那算法就得基于这个来做，索引也不例外。

主索引：按照唯一值ID值建立索引，也就是主键索引

辅助索引：非主键索引。

## mysql 索引分类

- 普通索引(index) 
- 唯一索引(UNIQUE) 
- 主索引(PRIMARY) 
- 外键索引 
- 复合索引

MYSQL索引使用：一条 SQL 语句，最多只能使用一个索引。

实际上，索引走一个也就够了。因为：如果要走3种索引算法 ，那第一层算完，拿出 ID 值，再去第二个索引算法中匹配，接着再去第3层匹配，最后再去找真实的物理数据地址。这样做意义已经不大了，走一层索引，直接再去扫描整表可能会更快些。

具体用哪个索引，MYSQL优化器，会根据自己的策略选择一个索引。

复合索引

上面说过，MYSQL一次只能走一个索引，但并不是说，可以把两个列组合起来，做一个索引。

单列索引就是树中的节点保存的数据是单个值，复合索引就是数据为多个值。但，既然是一个数据中保存多个值就得有先后顺序。所以，查找的时候，就牵扯到哪个字段在先，哪个字段在后了。最终MYSQL优化器，也会做出优化。只是个人觉得：如果是复杂索引，那保存的项目可能就是N次方了。索引应该非常大。

id in (123,467):实际执行是将IN转化成OR 然后，将满足条件的值放到一个临时表中，再去掉重复值，得出结果。这其中，不管id列是否有索引，数据库都不会用到该列的索引

不等号 是不能使用索引

show index from table_name

其中有列：Cardinality，散列数字，越大越好，平均数值组=索引基数/表总数据行，平均数值组越接近1就越有可能利用索引

具体索引使用的场景分析：

如果一列的值，重复值过多，二叉树就变成了线性查找，跟扫描整就没区别了。

频繁更新，会导致索引不停的在重做，那搜索的操作其实也没意义了。

# 锁机制

锁：一致性，防止多个请求，操作同一个会话，造成会话间读取数据不一致 。

表锁：开销小，加锁快，不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低

行锁：开销大，加锁慢，会出现死锁，锁定粒度小，发生锁冲突的概率最低，并发度最高

# myisam

表锁：表共享读锁(Table Read Lock)和表独占写锁(Table WriteLock)

共享读琐：俩个并发，A读，B也可以读，如果B要写，需要等待，如果A写，MYSQL报错

独占写锁：俩个并发，A写，B不可以读，B也不可以写

myisam:表锁，支持全文索引(不过没多大用处，且问题多多)，在执行SELECT前，自动给涉及的所有表加上读锁，在执行更新前，会自动给涉及的表加写锁，MYSQL自动添加，SO，MYISAM不会出现死锁。

所以，MYISA表的读写是串行，但在一定件下，也支持读写并发进行(但不能删除或者更新),concurrent_insert = 1.

同时：一个写锁请求跟一个读锁请求，MYSQL会先让写锁先执行，就算读锁快写锁一点，MYSQL仍然会让写锁先执行.mysql认为写比读更重要，这也是MYISZM不适合，大量<更新和查询>操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而阻塞。但如果写多，读少，比较适合MYISAM

MYISAM是默认给加锁，如果你自己加锁，就必须一次把所有的表全加锁，否则报错的

lock tables table1 read local,table2 write local;

select * from table1....

select * from table2....

unlock tables;

其中local:并发时，允许其它用户在表尾并发插入记录，以上加锁并没有实际作用

MyISAM键高速缓冲：将经常使用的数据缓冲在内存中，多个线程可以并行访问缓存

MyISAM:.frm(表结构).MYD (MYData,数据文件)。MYI (MYIndex,索引文件)。

# INNODB

行锁或表锁，支持事务、聚集索引

因为是聚集索引，所以主键索引必须得有，如果没有，MYSQL会介入挑一个字段建立。

#### 共享锁(S)

允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁

假设：

A：select * from table1 where id = 999 lock insharemode 加共享锁 此时

B：仍可以读table1数据，而且，还可以给此记录加 共享锁

#### 排他锁(X)

允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁

假设：

A：select * from table1 where id = 999 for update 加排他锁 此时

B：仍可以读table1数据，但不可以给此记录加排他锁，需要等上面解锁之后才可以

总结下：默认情况下select 是不会加任何锁的，那就是说，都是可以的，即使有其它的写请求依然可以读，好处就是：读写频繁的操作，效率依然很好。缺点就是：不能保证一致性。

如何避免：给所有读操作加上读锁，那么其它想读的请求，会先加读锁，因为已经被加了读锁，所以加锁失败，得等待。

del update insert 会自动给加上写锁

加锁，是给索引（而不是直接锁数据）加上行锁(间隙锁 NEXT-KEY locking)

总结下：查询时，只有某列走了索引，才能会给某行加锁，也就是先锁的是列，根据列，再锁行。否则就是表锁了。


# 意向锁


innodb 要加行锁之前，是要先加意向锁的~

为了允许行锁跟表锁共享，实现多粒度锁机制，INNODB 还有两种内部使用的意向锁，两种锁都是表锁

意向共享锁(IS):事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前，必须先取得该表的IS锁。

意向排他锁(IX):事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前，必须取得该表的IX锁。

如果，一个事务请求的锁模式与当前的锁兼容，INNODB就将请求的锁授予该事务

意向锁是INNODB自动加的。

对于UPDATE、DELETE、INSERT语句，INNODB会自动给涉及数据集加排他锁

对于普通的SELECT语句，INNODB不会加任何锁

一个事务只能执行了commit或rollback，才会释放锁，即：隐式锁，就是MYSQL存储引擎自己加不需要用户加。

发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。

但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。

间隙锁（Gap Lock），只锁间隙

记录锁（Record Lock）只锁记录

Next-Key Lock（代码中称为Ordinary Lock），同时锁住记录和间隙zA

http://www.searchdatabase.com.cn/showcontent_61663.htm

http://simpleframework.net/blog/v/38147.html

http://www.ha97.com/4170.html

表锁详解

读锁|写锁~共如下4个队列实现，两个队列保存 持有锁，另外两个是等待锁

Current read-lock queue (lock->read)

Pending read-lock queue (lock->read_wait)

Current write-lock queue (lock->write)

Pending write-lock queue (lock->write_wait)

一个事务请求读锁：

1，请求资源，在 Current write-lock queue 队列没有

2，写锁定等待队列（Pending write-lock queue）中没有更高优先级的写锁定等待

满足以上，插入 Current read-lock queue

如果不满足其中一条，进入 Pending read-lock queue

一个事务请求写锁：

1，检查 Current write-lock 队列中是否有相同的写锁，如果有，进入Current write-lock 队列

两个特殊情况：WRITE_DELAYED WRITE_CONCURRENT_INSERT 或者是TL_WRITE_ALLOW_WRITE，直接进入 Current write-lock 队列

读请求和写等待队列中的写锁请求的优先级规则主要为以下规则决定：

除了READ_HIGH_PRIORITY 的读锁定之外，Pending write-lock queue 中的WRITE 写锁定能够阻塞所有其他的读锁定；

READ_HIGH_PRIORITY 读锁定的请求能够阻塞所有Pending write-lock queue 中的写锁定；

除了WRITE 写锁定之外，Pending write-lock queue 中的其他任何写锁定都比读锁定的优先级低。

写锁定出现在Current write-lock queue 之后，会阻塞除了以下情况下的所有其他锁定的请求：

在某些存储引擎的允许下，可以允许一个WRITE_CONCURRENT_INSERT 写锁定请求

写锁定为WRITE_ALLOW_WRITE 的时候，允许除了WRITE_ONLY 之外的所有读和写锁定请求

写锁定为WRITE_ALLOW_READ 的时候，允许除了READ_NO_INSERT 之外的所有读锁定请求

写锁定为WRITE_DELAYED 的时候，允许除了READ_NO_INSERT 之外的所有读锁定请求

写锁定为WRITE_CONCURRENT_INSERT 的时候，允许除了READ_NO_INSERT 之外的所有读锁定请求